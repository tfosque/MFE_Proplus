"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRouteManager = exports.validateRouteConfig = void 0;
const router_1 = __importDefault(require("@koa/router"));
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const compose_endpoint_1 = __importDefault(require("./compose-endpoint"));
const policyOrMiddlewareSchema = utils_1.yup.lazy((value) => {
    if (typeof value === 'string') {
        return utils_1.yup.string().required();
    }
    if (typeof value === 'function') {
        return utils_1.yup.mixed().isFunction();
    }
    return utils_1.yup.object({
        name: utils_1.yup.string().required(),
        options: utils_1.yup.object().notRequired(), // any options
    });
});
const routeSchema = utils_1.yup.object({
    method: utils_1.yup.string().oneOf(['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'ALL']).required(),
    path: utils_1.yup.string().required(),
    handler: utils_1.yup.lazy((value) => {
        if (typeof value === 'string') {
            return utils_1.yup.string().required();
        }
        if (Array.isArray(value)) {
            return utils_1.yup.array().required();
        }
        return utils_1.yup.mixed().isFunction().required();
    }),
    config: utils_1.yup
        .object({
        auth: utils_1.yup.lazy((value) => {
            if (value === false) {
                return utils_1.yup.boolean().required();
            }
            return utils_1.yup.object({
                scope: utils_1.yup.array().of(utils_1.yup.string()).required(),
            });
        }),
        policies: utils_1.yup
            .array()
            // FIXME: fixed in yup v1
            .of(policyOrMiddlewareSchema)
            .notRequired(),
        middlewares: utils_1.yup
            .array()
            // FIXME: fixed in yup v1
            .of(policyOrMiddlewareSchema)
            .notRequired(),
    })
        .notRequired(),
});
const validateRouteConfig = (routeConfig) => {
    try {
        return routeSchema.validateSync(routeConfig, {
            strict: true,
            abortEarly: false,
            stripUnknown: true,
        });
    }
    catch (error) {
        if (error instanceof utils_1.yup.ValidationError) {
            throw new Error(`Invalid route config ${error.message}`);
        }
    }
};
exports.validateRouteConfig = validateRouteConfig;
const createRouteManager = (strapi, opts = {}) => {
    const { type } = opts;
    const composeEndpoint = (0, compose_endpoint_1.default)(strapi);
    const createRoute = (route, router) => {
        validateRouteConfig(route);
        // NOTE: the router type is used to tag controller actions and for authentication / authorization so we need to pass this info down to the route level
        const routeWithInfo = Object.assign(route, {
            info: {
                ...(route.info ?? {}),
                type: type || 'api',
            },
        });
        composeEndpoint(routeWithInfo, { router });
    };
    const addRoutes = (routes, router) => {
        if (Array.isArray(routes)) {
            routes.forEach((route) => createRoute(route, router));
        }
        else if (routes.routes) {
            const subRouter = new router_1.default({ prefix: routes.prefix });
            routes.routes.forEach((route) => {
                const hasPrefix = (0, fp_1.has)('prefix', route.config);
                createRoute(route, hasPrefix ? router : subRouter);
            });
            return router.use(subRouter.routes(), subRouter.allowedMethods());
        }
    };
    return {
        addRoutes,
    };
};
exports.createRouteManager = createRouteManager;
//# sourceMappingURL=routing.js.map