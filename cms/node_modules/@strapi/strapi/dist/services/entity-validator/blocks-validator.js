"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@strapi/utils");
const textNodeValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['text']).required(),
    text: utils_1.yup
        .string()
        .test('is-valid-text', 'Text must be defined with at least an empty string', (text) => {
        return typeof text === 'string' || text === '';
    }),
    bold: utils_1.yup.boolean(),
    italic: utils_1.yup.boolean(),
    underline: utils_1.yup.boolean(),
    strikethrough: utils_1.yup.boolean(),
    code: utils_1.yup.boolean(),
});
const linkNodeValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['link']).required(),
    url: utils_1.yup.string().url().required(),
    children: utils_1.yup.array().of(textNodeValidator).required(),
});
// TODO: remove any with a correct Type
const inlineNodeValidator = utils_1.yup.lazy((value) => {
    switch (value.type) {
        case 'text':
            return textNodeValidator;
        case 'link':
            return linkNodeValidator;
        default:
            return utils_1.yup.mixed().test('invalid-type', 'Inline node must be Text or Link', () => {
                return false;
            });
    }
});
const paragraphNodeValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['paragraph']).required(),
    children: utils_1.yup
        .array()
        .of(inlineNodeValidator)
        .min(1, 'Paragraph node children must have at least one Text or Link node')
        .required(),
});
const headingNodeValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['heading']).required(),
    level: utils_1.yup.number().oneOf([1, 2, 3, 4, 5, 6]).required(),
    children: utils_1.yup
        .array()
        .of(inlineNodeValidator)
        .min(1, 'Heading node children must have at least one Text or Link node')
        .required(),
});
const quoteNodeValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['quote']).required(),
    children: utils_1.yup
        .array()
        .of(inlineNodeValidator)
        .min(1, 'Quote node children must have at least one Text or Link node')
        .required(),
});
const codeBlockValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['code']).required(),
    syntax: utils_1.yup.string().nullable(),
    children: utils_1.yup
        .array()
        .of(textNodeValidator)
        .min(1, 'Quote node children must have at least one Text or Link node')
        .required(),
});
const listItemNode = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['list-item']).required(),
    children: utils_1.yup.array().of(inlineNodeValidator).required(),
});
const listNodeValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['list']).required(),
    format: utils_1.yup.string().equals(['ordered', 'unordered']).required(),
    children: utils_1.yup
        .array()
        .of(listItemNode)
        .min(1, 'List node children must have at least one ListItem node')
        .required(),
});
const imageNodeValidator = utils_1.yup.object().shape({
    type: utils_1.yup.string().equals(['image']).required(),
    image: utils_1.yup.object().shape({
        name: utils_1.yup.string().required(),
        alternativeText: utils_1.yup.string().nullable(),
        url: utils_1.yup.string().required(),
        caption: utils_1.yup.string().nullable(),
        width: utils_1.yup.number().required(),
        height: utils_1.yup.number().required(),
        formats: utils_1.yup.object().required(),
        hash: utils_1.yup.string().required(),
        ext: utils_1.yup.string().required(),
        mime: utils_1.yup.string().required(),
        size: utils_1.yup.number().required(),
        previewUrl: utils_1.yup.string().nullable(),
        provider: utils_1.yup.string().required(),
        provider_metadata: utils_1.yup.mixed().nullable(),
        createdAt: utils_1.yup.string().required(),
        updatedAt: utils_1.yup.string().required(),
    }),
    children: utils_1.yup.array().of(inlineNodeValidator).required(),
});
// TODO: remove the any and replace with a correct Type
const blockNodeValidator = utils_1.yup.lazy((value) => {
    switch (value.type) {
        case 'paragraph':
            return paragraphNodeValidator;
        case 'heading':
            return headingNodeValidator;
        case 'quote':
            return quoteNodeValidator;
        case 'list':
            return listNodeValidator;
        case 'image':
            return imageNodeValidator;
        case 'code':
            return codeBlockValidator;
        default:
            return utils_1.yup.mixed().test('invalid-type', 'Block node is of invalid type', () => {
                return false;
            });
    }
});
const blocksValidator = utils_1.yup.array().of(blockNodeValidator);
exports.default = (metas, options) => blocksValidator;
//# sourceMappingURL=blocks-validator.js.map