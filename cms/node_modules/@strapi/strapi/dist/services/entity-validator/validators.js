"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = __importDefault(require("@strapi/utils"));
const blocks_validator_1 = __importDefault(require("./blocks-validator"));
const { yup } = utils_1.default;
/* Validator utils */
/**
 * Adds minLength validator
 */
const addMinLengthValidator = (validator, { attr, }, { isDraft }) => {
    return attr.minLength && lodash_1.default.isInteger(attr.minLength) && !isDraft
        ? validator.min(attr.minLength)
        : validator;
};
/**
 * Adds maxLength validator
 * @returns {StringSchema}
 */
const addMaxLengthValidator = (validator, { attr, }) => {
    return attr.maxLength && lodash_1.default.isInteger(attr.maxLength) ? validator.max(attr.maxLength) : validator;
};
/**
 * Adds min integer validator
 * @returns {NumberSchema}
 */
const addMinIntegerValidator = (validator, { attr, }) => (lodash_1.default.isNumber(attr.min) ? validator.min(lodash_1.default.toInteger(attr.min)) : validator);
/**
 * Adds max integer validator
 */
const addMaxIntegerValidator = (validator, { attr, }) => (lodash_1.default.isNumber(attr.max) ? validator.max(lodash_1.default.toInteger(attr.max)) : validator);
/**
 * Adds min float/decimal validator
 */
const addMinFloatValidator = (validator, { attr, }) => (lodash_1.default.isNumber(attr.min) ? validator.min(attr.min) : validator);
/**
 * Adds max float/decimal validator
 */
const addMaxFloatValidator = (validator, { attr, }) => (lodash_1.default.isNumber(attr.max) ? validator.max(attr.max) : validator);
/**
 * Adds regex validator
 */
const addStringRegexValidator = (validator, { attr, }) => {
    return 'regex' in attr && !lodash_1.default.isUndefined(attr.regex)
        ? validator.matches(new RegExp(attr.regex), { excludeEmptyString: !attr.required })
        : validator;
};
/**
 * Adds unique validator
 */
const addUniqueValidator = (validator, { attr, model, updatedAttribute, entity }) => {
    if (attr.type !== 'uid' && !attr.unique) {
        return validator;
    }
    return validator.test('unique', 'This attribute must be unique', async (value) => {
        /**
         * If the attribute value is `null` we want to skip the unique validation.
         * Otherwise it'll only accept a single `null` entry in the database.
         */
        if (lodash_1.default.isNil(updatedAttribute.value)) {
            return true;
        }
        /**
         * If the attribute is unchanged we skip the unique verification. This will
         * prevent the validator to be triggered in case the user activated the
         * unique constraint after already creating multiple entries with
         * the same attribute value for that field.
         */
        if (entity && updatedAttribute.value === entity[updatedAttribute.name]) {
            return true;
        }
        const whereParams = entity
            ? { $and: [{ [updatedAttribute.name]: value }, { $not: { id: entity.id } }] }
            : { [updatedAttribute.name]: value };
        const record = await strapi.query(model.uid).findOne({
            select: ['id'],
            where: whereParams,
        });
        return !record;
    });
};
/* Type validators */
const stringValidator = (metas, options) => {
    let schema = yup.string().transform((val, originalVal) => originalVal);
    schema = addMinLengthValidator(schema, metas, options);
    schema = addMaxLengthValidator(schema, metas);
    schema = addStringRegexValidator(schema, metas);
    schema = addUniqueValidator(schema, metas);
    return schema;
};
const emailValidator = (metas, options) => {
    const schema = stringValidator(metas, options);
    return schema.email().min(1, '${path} cannot be empty');
};
const uidValidator = (metas, options) => {
    const schema = stringValidator(metas, options);
    return schema.matches(/^[A-Za-z0-9-_.~]*$/);
};
const enumerationValidator = ({ attr }) => {
    return yup
        .string()
        .oneOf((Array.isArray(attr.enum) ? attr.enum : [attr.enum]).concat(null));
};
const integerValidator = (metas) => {
    let schema = yup.number().integer();
    schema = addMinIntegerValidator(schema, metas);
    schema = addMaxIntegerValidator(schema, metas);
    schema = addUniqueValidator(schema, metas);
    return schema;
};
const floatValidator = (metas) => {
    let schema = yup.number();
    schema = addMinFloatValidator(schema, metas);
    schema = addMaxFloatValidator(schema, metas);
    schema = addUniqueValidator(schema, metas);
    return schema;
};
const bigintegerValidator = (metas) => {
    const schema = yup.mixed();
    return addUniqueValidator(schema, metas);
};
const datesValidator = (metas) => {
    const schema = yup.mixed();
    return addUniqueValidator(schema, metas);
};
exports.default = {
    string: stringValidator,
    text: stringValidator,
    richtext: stringValidator,
    password: stringValidator,
    email: emailValidator,
    enumeration: enumerationValidator,
    boolean: () => yup.boolean(),
    uid: uidValidator,
    json: () => yup.mixed(),
    integer: integerValidator,
    biginteger: bigintegerValidator,
    float: floatValidator,
    decimal: floatValidator,
    date: datesValidator,
    time: datesValidator,
    datetime: datesValidator,
    timestamp: datesValidator,
    blocks: blocks_validator_1.default,
};
//# sourceMappingURL=validators.js.map