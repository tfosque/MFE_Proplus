"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const strict_1 = __importDefault(require("assert/strict"));
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const INVALID_STRATEGY_MSG = 'Invalid auth strategy. Expecting an object with properties {name: string, authenticate: function, verify: function}';
const validStrategy = (strategy) => {
    (0, strict_1.default)((0, fp_1.has)('authenticate', strategy), INVALID_STRATEGY_MSG);
    (0, strict_1.default)(typeof strategy.authenticate === 'function', INVALID_STRATEGY_MSG);
    if ((0, fp_1.has)('verify', strategy)) {
        (0, strict_1.default)(typeof strategy.verify === 'function', INVALID_STRATEGY_MSG);
    }
};
const createAuthentication = () => {
    const strategies = {};
    return {
        register(type, strategy) {
            validStrategy(strategy);
            if (!strategies[type]) {
                strategies[type] = [];
            }
            strategies[type].push(strategy);
            return this;
        },
        async authenticate(ctx, next) {
            const route = ctx.state.route;
            // use route strategy
            const config = route?.config?.auth;
            if (config === false) {
                return next();
            }
            const routeStrategies = route.info.type ? strategies[route.info.type] : [];
            const configStrategies = (config?.strategies ?? routeStrategies ?? []);
            const strategiesToUse = configStrategies.reduce((acc, strategy) => {
                // Resolve by strategy name
                if (typeof strategy === 'string') {
                    const routeStrategy = routeStrategies.find((rs) => rs.name === strategy);
                    if (routeStrategy) {
                        acc.push(routeStrategy);
                    }
                }
                // Use the given strategy as is
                else if (typeof strategy === 'object') {
                    validStrategy(strategy);
                    acc.push(strategy);
                }
                return acc;
            }, []);
            for (const strategy of strategiesToUse) {
                const result = await strategy.authenticate(ctx);
                const { authenticated = false, credentials, ability = null, error = null } = result || {};
                if (error !== null) {
                    return ctx.unauthorized(error);
                }
                if (authenticated) {
                    ctx.state.isAuthenticated = true;
                    ctx.state.auth = {
                        strategy,
                        credentials,
                        ability,
                    };
                    return next();
                }
            }
            return ctx.unauthorized('Missing or invalid credentials');
        },
        async verify(auth, config = {}) {
            if (config === false) {
                return;
            }
            if (!auth) {
                throw new utils_1.errors.UnauthorizedError();
            }
            if (typeof auth.strategy.verify === 'function') {
                return auth.strategy.verify(auth, config);
            }
        },
    };
};
exports.default = createAuthentication;
//# sourceMappingURL=index.js.map