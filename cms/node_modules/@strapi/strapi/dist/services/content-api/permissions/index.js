"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const providers_1 = require("./providers");
const engine_1 = __importDefault(require("./engine"));
const typeSymbol = Symbol.for('__type__');
/**
 * Creates an handler that checks if the permission's action exists in the action registry
 */
const createValidatePermissionHandler = (actionProvider) => ({ permission }) => {
    const action = actionProvider.get(permission.action);
    // If the action isn't registered into the action provider, then ignore the permission and warn the user
    if (!action) {
        strapi.log.debug(`Unknown action "${permission.action}" supplied when registering a new permission`);
        return false;
    }
    return true;
};
/**
 * Create instances of providers and permission engine for the core content-API service.
 * Also, expose utilities to get informations about available actions and such.
 */
exports.default = (strapi) => {
    // NOTE: Here we define both an action and condition provider,
    // but at the moment, we're only using the action one.
    const providers = {
        action: (0, providers_1.createActionProvider)(),
        condition: (0, providers_1.createConditionProvider)(),
    };
    /**
     * Get a tree representation of the available Content API actions
     * based on the methods of the Content API controllers.
     *
     * @note Only actions bound to a content-API route are returned.
     */
    const getActionsMap = () => {
        const actionMap = {};
        /**
         * Check if a controller's action is bound to the
         * content-api by looking at a potential __type__ symbol
         */
        const isContentApi = (action) => {
            if (!lodash_1.default.has(action, typeSymbol)) {
                return false;
            }
            return action[typeSymbol].includes('content-api');
        };
        /**
         * Register actions from a specific API source into the result tree
         */
        const registerAPIsActions = (apis, source) => {
            lodash_1.default.forEach(apis, (api, apiName) => {
                const controllers = lodash_1.default.reduce(api.controllers, (acc, controller, controllerName) => {
                    const contentApiActions = lodash_1.default.pickBy(controller, isContentApi);
                    if (lodash_1.default.isEmpty(contentApiActions)) {
                        return acc;
                    }
                    acc[controllerName] = Object.keys(contentApiActions);
                    return acc;
                }, {});
                if (!lodash_1.default.isEmpty(controllers)) {
                    actionMap[`${source}::${apiName}`] = { controllers };
                }
            });
        };
        registerAPIsActions(strapi.api, 'api');
        registerAPIsActions(strapi.plugins, 'plugin');
        return actionMap;
    };
    /**
     * Register all the content-API's controllers actions into the action provider.
     * This method make use of the {@link getActionsMap} to generate the list of actions to register.
     *
     * @return {void}
     */
    const registerActions = async () => {
        const actionsMap = getActionsMap();
        // For each API
        for (const [api, value] of Object.entries(actionsMap)) {
            const { controllers } = value;
            // Register controllers methods as actions
            for (const [controller, actions] of Object.entries(controllers)) {
                // Register each action individually
                await Promise.all(actions.map((action) => {
                    const actionUID = `${api}.${controller}.${action}`;
                    return providers.action.register(actionUID, {
                        api,
                        controller,
                        action,
                        uid: actionUID,
                    });
                }));
            }
        }
    };
    // Create an instance of a content-API permission engine
    // and binds a custom validation handler to it
    const engine = (0, engine_1.default)({ providers });
    engine.on('before-format::validate.permission', createValidatePermissionHandler(providers.action));
    return {
        engine,
        providers,
        registerActions,
        getActionsMap,
    };
};
//# sourceMappingURL=index.js.map