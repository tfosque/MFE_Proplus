"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const transform_1 = require("./transform");
/**
 * Returns a single type controller to handle default core-api actions
 */
const createSingleTypeController = ({ contentType, }) => {
    const uid = contentType.uid;
    return {
        /**
         * Retrieve single type content
         *
         */
        async find(ctx) {
            await this.validateQuery(ctx);
            const sanitizedQuery = await this.sanitizeQuery(ctx);
            const entity = await strapi.service(uid).find(sanitizedQuery);
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            return this.transformResponse(sanitizedEntity);
        },
        /**
         * create or update single type content.
         *
         * @return {Object}
         */
        async update(ctx) {
            const { query } = ctx.request;
            const body = (0, transform_1.parseBody)(ctx);
            if (!(0, fp_1.isObject)(body.data)) {
                throw new utils_1.errors.ValidationError('Missing "data" payload in the request body');
            }
            const sanitizedInputData = await this.sanitizeInput(body.data, ctx);
            const entity = await strapi.service(uid).createOrUpdate({
                ...query,
                data: sanitizedInputData,
                files: 'files' in body ? body.files : undefined,
            });
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            return this.transformResponse(sanitizedEntity);
        },
        async delete(ctx) {
            const { query } = ctx;
            const entity = await strapi.service(uid).delete(query);
            const sanitizedEntity = await this.sanitizeOutput(entity, ctx);
            return this.transformResponse(sanitizedEntity);
        },
    };
};
exports.default = createSingleTypeController;
//# sourceMappingURL=single-type.js.map