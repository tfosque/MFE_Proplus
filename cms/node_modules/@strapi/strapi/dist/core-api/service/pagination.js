"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldCount = exports.transformPaginationResponse = exports.convertPagedToStartLimit = exports.getPaginationInfo = void 0;
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
/**
 * Default limit values from config
 */
const getLimitConfigDefaults = () => ({
    defaultLimit: (0, fp_1.toNumber)(strapi.config.get('api.rest.defaultLimit', 25)),
    maxLimit: (0, fp_1.toNumber)(strapi.config.get('api.rest.maxLimit')) || null,
});
/**
 * Should maxLimit be used as the limit or not
 */
const shouldApplyMaxLimit = (limit, maxLimit, { isPagedPagination = false } = {}) => (!isPagedPagination && limit === -1) || (maxLimit !== null && limit > maxLimit);
const shouldCount = (params) => {
    if ((0, fp_1.has)('pagination.withCount', params)) {
        const withCount = params.pagination?.withCount;
        if (typeof withCount === 'boolean') {
            return withCount;
        }
        if (typeof withCount === 'undefined') {
            return false;
        }
        if (['true', 't', '1', 1].includes(withCount)) {
            return true;
        }
        if (['false', 'f', '0', 0].includes(withCount)) {
            return false;
        }
        throw new utils_1.errors.ValidationError('Invalid withCount parameter. Expected "t","1","true","false","0","f"');
    }
    return Boolean(strapi.config.get('api.rest.withCount', true));
};
exports.shouldCount = shouldCount;
const isOffsetPagination = (pagination) => (0, fp_1.has)('start', pagination) || (0, fp_1.has)('limit', pagination);
const isPagedPagination = (pagination) => (0, fp_1.has)('page', pagination) || (0, fp_1.has)('pageSize', pagination);
const getPaginationInfo = (params) => {
    const { defaultLimit, maxLimit } = getLimitConfigDefaults();
    const { pagination } = params;
    const isPaged = isPagedPagination(pagination);
    const isOffset = isOffsetPagination(pagination);
    if (isOffset && isPaged) {
        throw new utils_1.errors.ValidationError('Invalid pagination parameters. Expected either start/limit or page/pageSize');
    }
    if (!isOffset && !isPaged) {
        return {
            page: 1,
            pageSize: defaultLimit,
        };
    }
    if (isPagedPagination(pagination)) {
        const pageSize = (0, fp_1.isUndefined)(pagination.pageSize)
            ? defaultLimit
            : Math.max(1, (0, fp_1.toNumber)(pagination.pageSize));
        return {
            page: Math.max(1, (0, fp_1.toNumber)(pagination.page || 1)),
            pageSize: typeof maxLimit === 'number' &&
                shouldApplyMaxLimit(pageSize, maxLimit, { isPagedPagination: true })
                ? maxLimit
                : Math.max(1, pageSize),
        };
    }
    const limit = (0, fp_1.isUndefined)(pagination.limit) ? defaultLimit : (0, fp_1.toNumber)(pagination.limit);
    return {
        start: Math.max(0, (0, fp_1.toNumber)(pagination.start || 0)),
        limit: shouldApplyMaxLimit(limit, maxLimit) ? maxLimit || -1 : Math.max(1, limit),
    };
};
exports.getPaginationInfo = getPaginationInfo;
const convertPagedToStartLimit = (paginationInfo) => {
    if ('page' in paginationInfo) {
        const { page, pageSize } = paginationInfo;
        return {
            start: (page - 1) * pageSize,
            limit: pageSize,
        };
    }
    return paginationInfo;
};
exports.convertPagedToStartLimit = convertPagedToStartLimit;
const transformPaginationResponse = (paginationInfo, count) => {
    if ('page' in paginationInfo) {
        return {
            ...paginationInfo,
            pageCount: Math.ceil(count / paginationInfo.pageSize),
            total: count,
        };
    }
    return {
        ...paginationInfo,
        total: count,
    };
};
exports.transformPaginationResponse = transformPaginationResponse;
//# sourceMappingURL=pagination.js.map