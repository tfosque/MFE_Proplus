"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable vars-on-top */
/* eslint-disable no-var */
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const fp_1 = require("lodash/fp");
const logger_1 = require("@strapi/logger");
const database_1 = require("@strapi/database");
const utils_1 = require("@strapi/utils");
const app_configuration_1 = __importDefault(require("./core/app-configuration"));
const factories = __importStar(require("./factories"));
const compile_1 = __importDefault(require("./compile"));
const utils = __importStar(require("./utils"));
const container_1 = require("./container");
const fs_1 = __importDefault(require("./services/fs"));
const event_hub_1 = __importDefault(require("./services/event-hub"));
const server_1 = require("./services/server");
const webhook_runner_1 = __importDefault(require("./services/webhook-runner"));
const webhook_store_1 = require("./services/webhook-store");
const core_store_1 = require("./services/core-store");
const entity_service_1 = __importDefault(require("./services/entity-service"));
const cron_1 = __importDefault(require("./services/cron"));
const entity_validator_1 = __importDefault(require("./services/entity-validator"));
const metrics_1 = __importDefault(require("./services/metrics"));
const request_context_1 = __importDefault(require("./services/request-context"));
const auth_1 = __importDefault(require("./services/auth"));
const custom_fields_1 = __importDefault(require("./services/custom-fields"));
const content_api_1 = __importDefault(require("./services/content-api"));
const update_notifier_1 = __importDefault(require("./utils/update-notifier"));
const startup_logger_1 = __importDefault(require("./utils/startup-logger"));
const fetch_1 = require("./utils/fetch");
const lifecycles_1 = require("./utils/lifecycles");
const ee_1 = __importDefault(require("./utils/ee"));
const content_types_1 = __importDefault(require("./core/registries/content-types"));
const services_1 = __importDefault(require("./core/registries/services"));
const policies_1 = __importDefault(require("./core/registries/policies"));
const middlewares_1 = __importDefault(require("./core/registries/middlewares"));
const hooks_1 = __importDefault(require("./core/registries/hooks"));
const controllers_1 = __importDefault(require("./core/registries/controllers"));
const modules_1 = __importDefault(require("./core/registries/modules"));
const plugins_1 = __importDefault(require("./core/registries/plugins"));
const custom_fields_2 = __importDefault(require("./core/registries/custom-fields"));
const config_1 = __importDefault(require("./core/registries/config"));
const apis_1 = __importDefault(require("./core/registries/apis"));
const bootstrap_1 = __importDefault(require("./core/bootstrap"));
const loaders_1 = __importDefault(require("./core/loaders"));
const signals_1 = require("./utils/signals");
const dynamic_zones_1 = __importDefault(require("./services/utils/dynamic-zones"));
const sanitizers_1 = __importDefault(require("./core/registries/sanitizers"));
const validators_1 = __importDefault(require("./core/registries/validators"));
const convert_custom_field_type_1 = __importDefault(require("./utils/convert-custom-field-type"));
// TODO: move somewhere else
const draftAndPublishSync = __importStar(require("./migrations/draft-publish"));
/**
 * Resolve the working directories based on the instance options.
 *
 * Behavior:
 * - `appDir` is the directory where Strapi will write every file (schemas, generated APIs, controllers or services)
 * - `distDir` is the directory where Strapi will read configurations, schemas and any compiled code
 *
 * Default values:
 * - If `appDir` is `undefined`, it'll be set to `process.cwd()`
 * - If `distDir` is `undefined`, it'll be set to `appDir`
 */
const resolveWorkingDirectories = (opts) => {
    const cwd = process.cwd();
    const appDir = opts.appDir ? path_1.default.resolve(cwd, opts.appDir) : cwd;
    const distDir = opts.distDir ? path_1.default.resolve(cwd, opts.distDir) : appDir;
    return { app: appDir, dist: distDir };
};
const reloader = (strapi) => {
    const state = {
        shouldReload: 0,
        isWatching: true,
    };
    function reload() {
        if (state.shouldReload > 0) {
            // Reset the reloading state
            state.shouldReload -= 1;
            reload.isReloading = false;
            return;
        }
        if (strapi.config.get('autoReload')) {
            process.send?.('reload');
        }
    }
    Object.defineProperty(reload, 'isWatching', {
        configurable: true,
        enumerable: true,
        set(value) {
            // Special state when the reloader is disabled temporarly (see GraphQL plugin example).
            if (state.isWatching === false && value === true) {
                state.shouldReload += 1;
            }
            state.isWatching = value;
        },
        get() {
            return state.isWatching;
        },
    });
    reload.isReloading = false;
    reload.isWatching = true;
    return reload;
};
class Strapi {
    server;
    container;
    log;
    fs;
    eventHub;
    startupLogger;
    cron;
    webhookRunner;
    webhookStore;
    store;
    entityValidator;
    entityService;
    telemetry;
    requestContext;
    customFields;
    fetch;
    dirs;
    admin;
    isLoaded;
    db;
    app;
    EE;
    components;
    reload;
    constructor(opts = {}) {
        (0, signals_1.destroyOnSignal)(this);
        const rootDirs = resolveWorkingDirectories(opts);
        // Load the app configuration from the dist directory
        const appConfig = (0, app_configuration_1.default)(rootDirs, opts);
        // Instantiate the Strapi container
        this.container = (0, container_1.createContainer)(this)
            .register('config', (0, config_1.default)(appConfig))
            .register('content-types', (0, content_types_1.default)())
            .register('services', (0, services_1.default)(this))
            .register('policies', (0, policies_1.default)())
            .register('middlewares', (0, middlewares_1.default)())
            .register('hooks', (0, hooks_1.default)())
            .register('controllers', (0, controllers_1.default)(this))
            .register('modules', (0, modules_1.default)(this))
            .register('plugins', (0, plugins_1.default)(this))
            .register('custom-fields', (0, custom_fields_2.default)(this))
            .register('apis', (0, apis_1.default)(this))
            .register('auth', (0, auth_1.default)())
            .register('content-api', (0, content_api_1.default)(this))
            .register('sanitizers', (0, sanitizers_1.default)())
            .register('validators', (0, validators_1.default)());
        this.components = {};
        // Create a mapping of every useful directory (for the app, dist and static directories)
        this.dirs = utils.getDirs(rootDirs, { strapi: this });
        // Strapi state management variables
        this.isLoaded = false;
        this.reload = reloader(this);
        // Instantiate the Koa app & the HTTP server
        this.server = (0, server_1.createServer)(this);
        // Strapi utils instantiation
        this.fs = (0, fs_1.default)(this);
        this.eventHub = (0, event_hub_1.default)();
        this.startupLogger = (0, startup_logger_1.default)(this);
        this.log = (0, logger_1.createLogger)(this.config.get('logger', {}));
        this.cron = (0, cron_1.default)();
        this.telemetry = (0, metrics_1.default)(this);
        this.requestContext = request_context_1.default;
        this.customFields = (0, custom_fields_1.default)(this);
        this.fetch = (0, fetch_1.createStrapiFetch)(this);
        (0, update_notifier_1.default)(this).notify();
        Object.defineProperty(this, 'EE', {
            get: () => {
                ee_1.default.init(this.dirs.app.root, this.log);
                return ee_1.default.isEE;
            },
            configurable: false,
        });
    }
    get config() {
        return this.container.get('config');
    }
    get services() {
        return this.container.get('services').getAll();
    }
    service(uid) {
        return this.container.get('services').get(uid);
    }
    get controllers() {
        return this.container.get('controllers').getAll();
    }
    controller(uid) {
        return this.container.get('controllers').get(uid);
    }
    get contentTypes() {
        return this.container.get('content-types').getAll();
    }
    contentType(name) {
        return this.container.get('content-types').get(name);
    }
    get policies() {
        return this.container.get('policies').getAll();
    }
    policy(name) {
        return this.container.get('policies').get(name);
    }
    get middlewares() {
        return this.container.get('middlewares').getAll();
    }
    middleware(name) {
        return this.container.get('middlewares').get(name);
    }
    get plugins() {
        return this.container.get('plugins').getAll();
    }
    plugin(name) {
        return this.container.get('plugins').get(name);
    }
    get hooks() {
        return this.container.get('hooks').getAll();
    }
    hook(name) {
        return this.container.get('hooks').get(name);
    }
    // api(name) {
    //   return this.container.get('apis').get(name);
    // }
    get api() {
        return this.container.get('apis').getAll();
    }
    get auth() {
        return this.container.get('auth');
    }
    get contentAPI() {
        return this.container.get('content-api');
    }
    get sanitizers() {
        return this.container.get('sanitizers');
    }
    get validators() {
        return this.container.get('validators');
    }
    async start() {
        try {
            if (!this.isLoaded) {
                await this.load();
            }
            await this.listen();
            return this;
        }
        catch (error) {
            return this.stopWithError(error);
        }
    }
    async destroy() {
        await this.server.destroy();
        await this.runLifecyclesFunctions(lifecycles_1.LIFECYCLES.DESTROY);
        this.eventHub.destroy();
        await this.db?.destroy();
        this.telemetry.destroy();
        this.cron.destroy();
        process.removeAllListeners();
        // @ts-expect-error: Allow clean delete of global.strapi to allow re-instanciation
        delete global.strapi;
    }
    sendStartupTelemetry() {
        // Emit started event.
        // do not await to avoid slower startup
        // This event is anonymous
        this.telemetry.send('didStartServer', {
            groupProperties: {
                database: this.config.get('database.connection.client'),
                plugins: Object.keys(this.plugins),
                numberOfAllContentTypes: lodash_1.default.size(this.contentTypes),
                numberOfComponents: lodash_1.default.size(this.components),
                numberOfDynamicZones: (0, dynamic_zones_1.default)(),
                environment: this.config.environment,
                // TODO: to add back
                // providers: this.config.installedProviders,
            },
        });
    }
    async openAdmin({ isInitialized }) {
        const shouldOpenAdmin = this.config.get('environment') === 'development' &&
            this.config.get('admin.autoOpen', true) !== false;
        if (shouldOpenAdmin && !isInitialized) {
            try {
                await utils.openBrowser(this.config);
                this.telemetry.send('didOpenTab');
            }
            catch (e) {
                this.telemetry.send('didNotOpenTab');
            }
        }
    }
    async postListen() {
        const isInitialized = await utils.isInitialized(this);
        this.startupLogger.logStartupMessage({ isInitialized });
        this.sendStartupTelemetry();
        this.openAdmin({ isInitialized });
    }
    /**
     * Add behaviors to the server
     */
    async listen() {
        return new Promise((resolve, reject) => {
            const onListen = async () => {
                try {
                    await this.postListen();
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            };
            const listenSocket = this.config.get('server.socket');
            if (listenSocket) {
                this.server.listen(listenSocket, onListen);
            }
            else {
                const { host, port } = this.config.get('server');
                this.server.listen(port, host, onListen);
            }
        });
    }
    stopWithError(err, customMessage) {
        this.log.debug(`⛔️ Server wasn't able to start properly.`);
        if (customMessage) {
            this.log.error(customMessage);
        }
        this.log.error(err);
        return this.stop();
    }
    stop(exitCode = 1) {
        this.destroy();
        if (this.config.get('autoReload')) {
            process.send?.('stop');
        }
        // Kill process
        process.exit(exitCode);
    }
    async loadAdmin() {
        await loaders_1.default.loadAdmin(this);
    }
    async loadPlugins() {
        await loaders_1.default.loadPlugins(this);
    }
    async loadPolicies() {
        await loaders_1.default.loadPolicies(this);
    }
    async loadAPIs() {
        await loaders_1.default.loadAPIs(this);
    }
    async loadComponents() {
        this.components = await loaders_1.default.loadComponents(this);
    }
    async loadMiddlewares() {
        await loaders_1.default.loadMiddlewares(this);
    }
    async loadApp() {
        this.app = await loaders_1.default.loadSrcIndex(this);
    }
    async loadSanitizers() {
        await loaders_1.default.loadSanitizers(this);
    }
    async loadValidators() {
        await loaders_1.default.loadValidators(this);
    }
    registerInternalHooks() {
        this.container
            .get('hooks')
            .set('strapi::content-types.beforeSync', utils_1.hooks.createAsyncParallelHook());
        this.container
            .get('hooks')
            .set('strapi::content-types.afterSync', utils_1.hooks.createAsyncParallelHook());
        this.hook('strapi::content-types.beforeSync').register(draftAndPublishSync.disable);
        this.hook('strapi::content-types.afterSync').register(draftAndPublishSync.enable);
    }
    async register() {
        await Promise.all([
            this.loadApp(),
            this.loadSanitizers(),
            this.loadValidators(),
            this.loadPlugins(),
            this.loadAdmin(),
            this.loadAPIs(),
            this.loadComponents(),
            this.loadMiddlewares(),
            this.loadPolicies(),
        ]);
        await (0, bootstrap_1.default)({ strapi: this });
        // init webhook runner
        this.webhookRunner = (0, webhook_runner_1.default)({
            eventHub: this.eventHub,
            logger: this.log,
            configuration: this.config.get('server.webhooks', {}),
            fetch: this.fetch,
        });
        this.registerInternalHooks();
        this.telemetry.register();
        await this.runLifecyclesFunctions(lifecycles_1.LIFECYCLES.REGISTER);
        // NOTE: Swap type customField for underlying data type
        (0, convert_custom_field_type_1.default)(this);
        return this;
    }
    async bootstrap() {
        const contentTypes = [
            core_store_1.coreStoreModel,
            webhook_store_1.webhookModel,
            ...Object.values(this.contentTypes),
            ...Object.values(this.components),
        ];
        this.db = await database_1.Database.init({
            ...this.config.get('database'),
            models: database_1.Database.transformContentTypes(contentTypes),
        });
        this.store = (0, core_store_1.createCoreStore)({ db: this.db });
        this.webhookStore = (0, webhook_store_1.createWebhookStore)({ db: this.db });
        this.entityValidator = entity_validator_1.default;
        this.entityService = (0, entity_service_1.default)({
            strapi: this,
            db: this.db,
            eventHub: this.eventHub,
            entityValidator: this.entityValidator,
        });
        if (this.config.get('server.cron.enabled', true)) {
            const cronTasks = this.config.get('server.cron.tasks', {});
            this.cron.add(cronTasks);
        }
        this.telemetry.bootstrap();
        let oldContentTypes;
        if (await this.db.getSchemaConnection().hasTable(core_store_1.coreStoreModel.collectionName)) {
            oldContentTypes = await this.store.get({
                type: 'strapi',
                name: 'content_types',
                key: 'schema',
            });
        }
        await this.hook('strapi::content-types.beforeSync').call({
            oldContentTypes,
            contentTypes: this.contentTypes,
        });
        await this.db.schema.sync();
        if (this.EE) {
            await ee_1.default.checkLicense({ strapi: this });
        }
        await this.hook('strapi::content-types.afterSync').call({
            oldContentTypes,
            contentTypes: this.contentTypes,
        });
        await this.store.set({
            type: 'strapi',
            name: 'content_types',
            key: 'schema',
            value: this.contentTypes,
        });
        await this.startWebhooks();
        await this.server.initMiddlewares();
        this.server.initRouting();
        await this.contentAPI.permissions.registerActions();
        await this.runLifecyclesFunctions(lifecycles_1.LIFECYCLES.BOOTSTRAP);
        this.cron.start();
        return this;
    }
    async load() {
        await this.register();
        await this.bootstrap();
        this.isLoaded = true;
        return this;
    }
    async startWebhooks() {
        const webhooks = await this.webhookStore?.findWebhooks();
        if (!webhooks) {
            return;
        }
        for (const webhook of webhooks) {
            this.webhookRunner?.add(webhook);
        }
    }
    async runLifecyclesFunctions(lifecycleName) {
        // plugins
        await this.container.get('modules')[lifecycleName]();
        // admin
        const adminLifecycleFunction = this.admin && this.admin[lifecycleName];
        if ((0, fp_1.isFunction)(adminLifecycleFunction)) {
            await adminLifecycleFunction({ strapi: this });
        }
        // user
        const userLifecycleFunction = this.app && this.app[lifecycleName];
        if ((0, fp_1.isFunction)(userLifecycleFunction)) {
            await userLifecycleFunction({ strapi: this });
        }
    }
    getModel(uid) {
        if (uid in this.contentTypes) {
            return this.contentTypes[uid];
        }
        if (uid in this.components) {
            return this.components[uid];
        }
    }
    /**
     * Binds queries with a specific model
     * @param {string} uid
     */
    query(uid) {
        return this.db.query(uid);
    }
}
const initFn = (options = {}) => {
    const strapi = new Strapi(options);
    global.strapi = strapi;
    return strapi;
};
const init = Object.assign(initFn, { factories, compile: compile_1.default });
exports.default = init;
//# sourceMappingURL=Strapi.js.map