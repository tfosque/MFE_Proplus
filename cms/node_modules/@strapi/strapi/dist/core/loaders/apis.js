"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_extra_1 = __importStar(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@strapi/utils");
const fp_1 = require("lodash/fp");
const DEFAULT_CONTENT_TYPE = {
    schema: {},
    actions: {},
    lifecycles: {},
};
// to handle names with numbers in it we first check if it is already in kebabCase
const normalizeName = (name) => ((0, utils_1.isKebabCase)(name) ? name : lodash_1.default.kebabCase(name));
const isDirectory = (fd) => fd.isDirectory();
const isDotFile = (fd) => fd.name.startsWith('.');
async function loadAPIs(strapi) {
    if (!(0, fs_extra_1.existsSync)(strapi.dirs.dist.api)) {
        return;
    }
    const apisFDs = await (await fs_extra_1.default.readdir(strapi.dirs.dist.api, { withFileTypes: true }))
        .filter(isDirectory)
        .filter(lodash_1.default.negate(isDotFile));
    const apis = {};
    // only load folders
    for (const apiFD of apisFDs) {
        const apiName = normalizeName(apiFD.name);
        const api = await loadAPI((0, path_1.join)(strapi.dirs.dist.api, apiFD.name));
        apis[apiName] = api;
    }
    validateContentTypesUnicity(apis);
    for (const apiName of Object.keys(apis)) {
        strapi.container.get('apis').add(apiName, apis[apiName]);
    }
}
exports.default = loadAPIs;
const validateContentTypesUnicity = (apis) => {
    const allApisSchemas = Object.values(apis).flatMap((api) => Object.values(api.contentTypes));
    const names = [];
    allApisSchemas.forEach(({ schema }) => {
        if (schema.info.singularName) {
            const singularName = lodash_1.default.kebabCase(schema.info.singularName);
            if (names.includes(singularName)) {
                throw new Error(`The singular name "${schema.info.singularName}" should be unique`);
            }
            names.push(singularName);
        }
        if (schema.info.pluralName) {
            const pluralName = lodash_1.default.kebabCase(schema.info.pluralName);
            if (names.includes(pluralName)) {
                throw new Error(`The plural name "${schema.info.pluralName}" should be unique`);
            }
            names.push(pluralName);
        }
    });
};
const loadAPI = async (dir) => {
    const [index, config, routes, controllers, services, policies, middlewares, contentTypes] = await Promise.all([
        loadIndex(dir),
        loadDir((0, path_1.join)(dir, 'config')),
        loadDir((0, path_1.join)(dir, 'routes')),
        loadDir((0, path_1.join)(dir, 'controllers')),
        loadDir((0, path_1.join)(dir, 'services')),
        loadDir((0, path_1.join)(dir, 'policies')),
        loadDir((0, path_1.join)(dir, 'middlewares')),
        loadContentTypes((0, path_1.join)(dir, 'content-types')),
    ]);
    return {
        ...(index || {}),
        config: config || {},
        routes: routes || [],
        controllers: controllers || {},
        services: services || {},
        policies: policies || {},
        middlewares: middlewares || {},
        contentTypes: contentTypes || {},
    };
};
const loadIndex = async (dir) => {
    if (await fs_extra_1.default.pathExists((0, path_1.join)(dir, 'index.js'))) {
        return loadFile((0, path_1.join)(dir, 'index.js'));
    }
};
const loadContentTypes = async (dir) => {
    if (!(await fs_extra_1.default.pathExists(dir))) {
        return;
    }
    const fds = await fs_extra_1.default.readdir(dir, { withFileTypes: true });
    const contentTypes = {};
    // only load folders
    for (const fd of fds) {
        if (fd.isFile()) {
            continue;
        }
        const contentTypeName = normalizeName(fd.name);
        const contentType = await loadDir((0, path_1.join)(dir, fd.name));
        if ((0, fp_1.isEmpty)(contentType) || (0, fp_1.isEmpty)(contentType.schema)) {
            throw new Error(`Could not load content type found at ${dir}`);
        }
        contentTypes[normalizeName(contentTypeName)] = lodash_1.default.defaults(contentType, DEFAULT_CONTENT_TYPE);
    }
    return contentTypes;
};
const loadDir = async (dir) => {
    if (!(await fs_extra_1.default.pathExists(dir))) {
        return;
    }
    const fds = await fs_extra_1.default.readdir(dir, { withFileTypes: true });
    const root = {};
    for (const fd of fds) {
        if (!fd.isFile() || (0, path_1.extname)(fd.name) === '.map') {
            continue;
        }
        const key = (0, path_1.basename)(fd.name, (0, path_1.extname)(fd.name));
        root[normalizeName(key)] = await loadFile((0, path_1.join)(dir, fd.name));
    }
    return root;
};
const loadFile = (file) => {
    const ext = (0, path_1.extname)(file);
    switch (ext) {
        case '.js':
            return (0, utils_1.importDefault)(file);
        case '.json':
            return fs_extra_1.default.readJSON(file);
        default:
            return {};
    }
};
//# sourceMappingURL=apis.js.map