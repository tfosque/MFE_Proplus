"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnabledPlugins = void 0;
/* eslint-disable @typescript-eslint/no-var-requires */
const path_1 = require("path");
const fs_1 = require("fs");
const lodash_1 = __importDefault(require("lodash"));
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const get_user_plugins_config_1 = require("./get-user-plugins-config");
const INTERNAL_PLUGINS = [
    '@strapi/plugin-content-manager',
    '@strapi/plugin-content-type-builder',
    '@strapi/plugin-email',
    '@strapi/plugin-upload',
];
const isStrapiPlugin = (info) => (0, fp_1.get)('strapi.kind', info) === 'plugin';
const validatePluginName = (pluginName) => {
    if (!(0, utils_1.isKebabCase)(pluginName)) {
        throw new Error(`Plugin name "${pluginName}" is not in kebab (an-example-of-kebab-case)`);
    }
};
const toDetailedDeclaration = (declaration) => {
    if (typeof declaration === 'boolean') {
        return { enabled: declaration };
    }
    const detailedDeclaration = {
        enabled: declaration.enabled,
    };
    if (declaration?.resolve) {
        let pathToPlugin = '';
        if (declaration.isModule) {
            /**
             * we only want the node_module here, not the package.json
             */
            pathToPlugin = (0, path_1.join)(declaration.resolve, '..');
        }
        else {
            try {
                pathToPlugin = (0, path_1.dirname)(require.resolve(declaration.resolve));
            }
            catch (e) {
                pathToPlugin = (0, path_1.resolve)(strapi.dirs.app.root, declaration.resolve);
                if (!(0, fs_1.existsSync)(pathToPlugin) || !(0, fs_1.statSync)(pathToPlugin).isDirectory()) {
                    throw new Error(`${declaration.resolve} couldn't be resolved`);
                }
            }
        }
        detailedDeclaration.pathToPlugin = pathToPlugin;
    }
    return detailedDeclaration;
};
const getEnabledPlugins = async (strapi, { client } = { client: false }) => {
    const internalPlugins = {};
    for (const dep of INTERNAL_PLUGINS) {
        const packagePath = (0, path_1.join)(dep, 'package.json');
        const packageInfo = require(packagePath);
        validatePluginName(packageInfo.strapi.name);
        internalPlugins[packageInfo.strapi.name] = {
            ...toDetailedDeclaration({ enabled: true, resolve: packagePath, isModule: client }),
            info: packageInfo.strapi,
        };
    }
    const installedPlugins = {};
    const dependencies = strapi.config.get('info.dependencies', {});
    for (const dep of Object.keys(dependencies)) {
        const packagePath = (0, path_1.join)(dep, 'package.json');
        let packageInfo;
        try {
            packageInfo = require(packagePath);
        }
        catch {
            continue;
        }
        if (isStrapiPlugin(packageInfo)) {
            validatePluginName(packageInfo.strapi.name);
            installedPlugins[packageInfo.strapi.name] = {
                ...toDetailedDeclaration({ enabled: true, resolve: packagePath, isModule: client }),
                info: {
                    ...packageInfo.strapi,
                    packageName: packageInfo.name,
                },
            };
        }
    }
    const declaredPlugins = {};
    const userPluginsConfig = await (0, get_user_plugins_config_1.getUserPluginsConfig)();
    lodash_1.default.forEach(userPluginsConfig, (declaration, pluginName) => {
        validatePluginName(pluginName);
        declaredPlugins[pluginName] = {
            ...toDetailedDeclaration(declaration),
            info: {},
        };
        const { pathToPlugin } = declaredPlugins[pluginName];
        // for manually resolved plugins
        if (pathToPlugin) {
            const packagePath = (0, path_1.join)(pathToPlugin, 'package.json');
            const packageInfo = require(packagePath);
            if (isStrapiPlugin(packageInfo)) {
                declaredPlugins[pluginName].info = packageInfo.strapi || {};
            }
        }
    });
    const declaredPluginsResolves = (0, fp_1.map)((0, fp_1.prop)('pathToPlugin'), declaredPlugins);
    const installedPluginsNotAlreadyUsed = (0, fp_1.pickBy)((p) => !declaredPluginsResolves.includes(p.pathToPlugin), installedPlugins);
    const enabledPlugins = (0, fp_1.pipe)((0, fp_1.defaultsDeep)(declaredPlugins), (0, fp_1.defaultsDeep)(installedPluginsNotAlreadyUsed), (0, fp_1.pickBy)((p) => p.enabled))(internalPlugins);
    return enabledPlugins;
};
exports.getEnabledPlugins = getEnabledPlugins;
//# sourceMappingURL=get-enabled-plugins.js.map