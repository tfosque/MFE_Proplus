"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createContentType = void 0;
const fp_1 = require("lodash/fp");
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@strapi/utils");
const validator_1 = require("./validator");
const { CREATED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE, } = utils_1.contentTypes.constants;
const createContentType = (uid, definition) => {
    try {
        (0, validator_1.validateContentTypeDefinition)(definition);
    }
    catch (e) {
        if (e instanceof utils_1.yup.ValidationError) {
            throw new Error(`Content Type Definition is invalid for ${uid}'.\n${e.errors}`);
        }
        throw e;
    }
    const { schema, actions, lifecycles } = (0, fp_1.cloneDeep)(definition);
    // general info
    Object.assign(schema, {
        kind: schema.kind || 'collectionType',
        __schema__: pickSchema(definition.schema),
        modelType: 'contentType',
        modelName: definition.schema.info.singularName,
        connection: 'default',
    });
    if (uid.startsWith('api::')) {
        Object.assign(schema, {
            uid,
            apiName: uid.split('::')[1].split('.')[0],
            collectionName: schema.collectionName || schema.info.singularName,
            globalId: getGlobalId(schema, schema.info.singularName),
        });
    }
    else if (uid.startsWith('plugin::')) {
        const pluginName = uid.split('::')[1].split('.')[0];
        Object.assign(schema, {
            uid,
            plugin: pluginName,
            collectionName: schema.collectionName || `${pluginName}_${schema.info.singularName}`.toLowerCase(),
            globalId: getGlobalId(schema, schema.info.singularName, pluginName),
        });
    }
    else if (uid.startsWith('admin::')) {
        Object.assign(schema, {
            uid,
            plugin: 'admin',
            globalId: getGlobalId(schema, schema.info.singularName, 'admin'),
        });
    }
    else {
        throw new Error(`Incorrect Content Type UID "${uid}". The UID should start with api::, plugin:: or admin::.`);
    }
    // attributes
    Object.assign(schema.attributes, {
        [CREATED_AT_ATTRIBUTE]: {
            type: 'datetime',
        },
        // TODO: handle on edit set to new date
        [UPDATED_AT_ATTRIBUTE]: {
            type: 'datetime',
        },
    });
    if (utils_1.contentTypes.hasDraftAndPublish(schema)) {
        schema.attributes[PUBLISHED_AT_ATTRIBUTE] = {
            type: 'datetime',
            configurable: false,
            writable: true,
            visible: false,
        };
    }
    const isPrivate = !lodash_1.default.get(schema, 'options.populateCreatorFields', false);
    schema.attributes[CREATED_BY_ATTRIBUTE] = {
        type: 'relation',
        relation: 'oneToOne',
        target: 'admin::user',
        configurable: false,
        writable: false,
        visible: false,
        useJoinTable: false,
        private: isPrivate,
    };
    schema.attributes[UPDATED_BY_ATTRIBUTE] = {
        type: 'relation',
        relation: 'oneToOne',
        target: 'admin::user',
        configurable: false,
        writable: false,
        visible: false,
        useJoinTable: false,
        private: isPrivate,
    };
    Object.assign(schema, { actions, lifecycles });
    return schema;
};
exports.createContentType = createContentType;
const getGlobalId = (model, modelName, prefix) => {
    const globalId = prefix ? `${prefix}-${modelName}` : modelName;
    return model.globalId || lodash_1.default.upperFirst(lodash_1.default.camelCase(globalId));
};
const pickSchema = (model) => {
    const schema = lodash_1.default.cloneDeep(lodash_1.default.pick(model, [
        'connection',
        'collectionName',
        'info',
        'options',
        'pluginOptions',
        'attributes',
    ]));
    schema.kind = model.kind || 'collectionType';
    return schema;
};
//# sourceMappingURL=index.js.map