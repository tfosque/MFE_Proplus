"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fp_1 = require("lodash/fp");
const content_type_1 = require("../domain/content-type");
const utils_1 = require("../utils");
const validateKeySameToSingularName = (contentTypes) => {
    for (const ctName of Object.keys(contentTypes)) {
        const contentType = contentTypes[ctName];
        if (ctName !== contentType.schema.info.singularName) {
            throw new Error(`The key of the content-type should be the same as its singularName. Found ${ctName} and ${contentType.schema.info.singularName}.`);
        }
    }
};
const contentTypesRegistry = () => {
    const contentTypes = {};
    return {
        /**
         * Returns this list of registered contentTypes uids
         */
        keys() {
            return Object.keys(contentTypes);
        },
        /**
         * Returns the instance of a contentType. Instantiate the contentType if not already done
         */
        get(uid) {
            return contentTypes[uid];
        },
        /**
         * Returns a map with all the contentTypes in a namespace
         */
        getAll(namespace) {
            return (0, fp_1.pickBy)((_, uid) => (0, utils_1.hasNamespace)(uid, namespace))(contentTypes);
        },
        /**
         * Registers a contentType
         */
        set(uid, contentType) {
            contentTypes[uid] = contentType;
            return this;
        },
        /**
         * Registers a map of contentTypes for a specific namespace
         */
        add(namespace, newContentTypes) {
            validateKeySameToSingularName(newContentTypes);
            for (const rawCtName of Object.keys(newContentTypes)) {
                const uid = (0, utils_1.addNamespace)(rawCtName, namespace);
                if ((0, fp_1.has)(uid, contentTypes)) {
                    throw new Error(`Content-type ${uid} has already been registered.`);
                }
                contentTypes[uid] = (0, content_type_1.createContentType)(uid, newContentTypes[rawCtName]);
            }
        },
        /**
         * Wraps a contentType to extend it
         */
        extend(ctUID, extendFn) {
            const currentContentType = this.get(ctUID);
            if (!currentContentType) {
                throw new Error(`Content-Type ${ctUID} doesn't exist`);
            }
            const newContentType = extendFn(currentContentType);
            contentTypes[ctUID] = newContentType;
            return this;
        },
    };
};
exports.default = contentTypesRegistry;
//# sourceMappingURL=content-types.js.map