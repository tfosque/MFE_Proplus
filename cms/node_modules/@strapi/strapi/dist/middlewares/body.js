"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.body = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const fp_1 = require("lodash/fp");
const koa_body_1 = __importDefault(require("koa-body"));
const mime_types_1 = __importDefault(require("mime-types"));
const defaults = {
    multipart: true,
    patchKoa: true,
};
function ensureFileMimeType(file) {
    if (!file.type) {
        file.type = mime_types_1.default.lookup(file.name) || 'application/octet-stream';
    }
}
function getFiles(ctx) {
    return ctx?.request?.files?.files;
}
const bodyMiddleware = (config, { strapi }) => {
    const bodyConfig = (0, fp_1.defaultsDeep)(defaults, config);
    let gqlEndpoint;
    if (strapi.plugin('graphql')) {
        const { config: gqlConfig } = strapi.plugin('graphql');
        gqlEndpoint = gqlConfig('endpoint');
    }
    return async (ctx, next) => {
        // TODO: find a better way later
        if (gqlEndpoint && ctx.url === gqlEndpoint) {
            await next();
        }
        else {
            try {
                await (0, koa_body_1.default)({ patchKoa: true, ...bodyConfig })(ctx, async () => { });
                const files = getFiles(ctx);
                /**
                 * in case the mime-type wasn't sent, Strapi tries to guess it
                 * from the file extension, to avoid a corrupt database state
                 */
                if (files) {
                    if (Array.isArray(files)) {
                        files.forEach(ensureFileMimeType);
                    }
                    else {
                        ensureFileMimeType(files);
                    }
                }
                await next();
            }
            catch (error) {
                if (error instanceof Error &&
                    error.message &&
                    error.message.includes('maxFileSize exceeded')) {
                    return ctx.payloadTooLarge('FileTooBig');
                }
                throw error;
            }
        }
        const files = getFiles(ctx);
        // clean any file that was uploaded
        if (files) {
            if (Array.isArray(files)) {
                // not awaiting to not slow the request
                Promise.all(files.map((file) => fs_extra_1.default.remove(file.path)));
            }
            else if (files && files.path) {
                // not awaiting to not slow the request
                fs_extra_1.default.remove(files.path);
            }
            delete ctx.request.files;
        }
    };
};
exports.body = bodyMiddleware;
//# sourceMappingURL=body.js.map