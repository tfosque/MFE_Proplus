"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dtsTask = void 0;
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const ora_1 = __importDefault(require("ora"));
const typescript_1 = __importDefault(require("typescript"));
class TSConfigNotFoundError extends Error {
    get code() {
        return 'TS_CONFIG_NOT_FOUND';
    }
}
/**
 * @description Load a tsconfig.json file and return the parsed config
 *
 * @internal
 */
const loadTsConfig = async ({ cwd, path }) => {
    const configPath = typescript_1.default.findConfigFile(cwd, typescript_1.default.sys.fileExists, path);
    if (!configPath) {
        throw new TSConfigNotFoundError(`could not find a valid '${path}'`);
    }
    const configFile = typescript_1.default.readConfigFile(configPath, typescript_1.default.sys.readFile);
    return typescript_1.default.parseJsonConfigFileContent(configFile.config, typescript_1.default.sys, cwd);
};
/**
 * @description
 *
 * @internal
 */
const buildTypes = ({ cwd, logger, outDir, tsconfig }) => {
    const compilerOptions = {
        ...tsconfig.options,
        declaration: true,
        declarationDir: outDir,
        emitDeclarationOnly: true,
        noEmit: false,
        outDir,
    };
    const program = typescript_1.default.createProgram(tsconfig.fileNames, compilerOptions);
    const emitResult = program.emit();
    const allDiagnostics = typescript_1.default.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
    for (const diagnostic of allDiagnostics) {
        if (diagnostic.file && diagnostic.start) {
            const { line, character } = typescript_1.default.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
            const message = typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
            const file = path_1.default.relative(cwd, diagnostic.file.fileName);
            const output = [
                `${chalk_1.default.cyan(file)}:${chalk_1.default.cyan(line + 1)}:${chalk_1.default.cyan(character + 1)} - `,
                `${chalk_1.default.gray(`TS${diagnostic.code}:`)} ${message}`,
            ].join('');
            if (diagnostic.category === typescript_1.default.DiagnosticCategory.Error) {
                logger.error(output);
            }
            if (diagnostic.category === typescript_1.default.DiagnosticCategory.Warning) {
                logger.warn(output);
            }
            if (diagnostic.category === typescript_1.default.DiagnosticCategory.Message) {
                logger.info(output);
            }
            if (diagnostic.category === typescript_1.default.DiagnosticCategory.Suggestion) {
                logger.info(output);
            }
        }
        else {
            logger.info(typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n'));
        }
    }
    if (emitResult.emitSkipped) {
        const errors = allDiagnostics.filter((diag) => diag.category === typescript_1.default.DiagnosticCategory.Error);
        if (errors.length) {
            throw new Error('Failed to compile TypeScript definitions');
        }
    }
};
const dtsTask = {
    _spinner: null,
    print(ctx, task) {
        const entries = [
            '   entries:',
            ...task.entries.map((entry) => [
                `    – `,
                chalk_1.default.green(`${entry.importId} `),
                `${chalk_1.default.cyan(entry.sourcePath)} ${chalk_1.default.gray('→')} ${chalk_1.default.cyan(entry.targetPath)}`,
            ].join('')),
            '',
        ];
        this._spinner = (0, ora_1.default)(`Building type files:\n`).start();
        ctx.logger.log([...entries].join('\n'));
    },
    async run(ctx, task) {
        try {
            await Promise.all(task.entries.map(async (entry) => {
                const config = await loadTsConfig({
                    /**
                     * TODO: this will not scale and assumes all project sourcePaths are `src/index.ts`
                     * so we can go back to the "root" of the project...
                     */
                    cwd: path_1.default.join(ctx.cwd, entry.sourcePath, '..', '..'),
                    path: 'tsconfig.build.json',
                }).catch((err) => {
                    if (err instanceof TSConfigNotFoundError) {
                        return undefined;
                    }
                    throw err;
                });
                if (config) {
                    ctx.logger.debug(`TS config for '${entry.sourcePath}': \n`, config);
                }
                else {
                    ctx.logger.warn(`You've added a types entry but no tsconfig.json was found for ${entry.targetPath}. Skipping...`);
                    return;
                }
                const { outDir } = config.raw.compilerOptions;
                if (!outDir) {
                    throw new Error("tsconfig.json is missing 'compilerOptions.outDir'");
                }
                await buildTypes({
                    cwd: ctx.cwd,
                    logger: ctx.logger,
                    outDir: path_1.default.relative(ctx.cwd, outDir),
                    tsconfig: config,
                });
            }));
            await this.success(ctx, task);
        }
        catch (err) {
            this.fail(ctx, task, err);
        }
    },
    async success() {
        this._spinner?.succeed('Built type files');
    },
    async fail(ctx, task, err) {
        this._spinner?.fail('Failed to build type files');
        throw err;
    },
};
exports.dtsTask = dtsTask;
//# sourceMappingURL=dts.js.map