"use strict";
/**
 * This file includes hooks to use for commander.hook and argParsers for commander.argParser
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forceOption = exports.confirmMessage = exports.getCommanderConfirmMessage = exports.promptEncryptionKey = exports.parseInteger = exports.parseURL = exports.parseList = exports.getParseListWithChoices = void 0;
const inquirer_1 = __importDefault(require("inquirer"));
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const fp_1 = require("lodash/fp");
const helpers_1 = require("./helpers");
/**
 * argParser: Parse a comma-delimited string as an array
 */
const parseList = (value) => {
    try {
        return value.split(',').map((item) => item.trim()); // trim shouldn't be necessary but might help catch unexpected whitespace characters
    }
    catch (e) {
        (0, helpers_1.exitWith)(1, `Unrecognized input: ${value}`);
    }
    return [];
};
exports.parseList = parseList;
/**
 * Returns an argParser that returns a list
 */
const getParseListWithChoices = (choices, errorMessage = 'Invalid options:') => {
    return (value) => {
        const list = parseList(value);
        const invalid = list.filter((item) => {
            return !choices.includes(item);
        });
        if (invalid.length > 0) {
            (0, helpers_1.exitWith)(1, `${errorMessage}: ${invalid.join(',')}`);
        }
        return list;
    };
};
exports.getParseListWithChoices = getParseListWithChoices;
/**
 * argParser: Parse a string as an integer
 */
const parseInteger = (value) => {
    // parseInt takes a string and a radix
    const parsedValue = parseInt(value, 10);
    if ((0, fp_1.isNaN)(parsedValue)) {
        throw new commander_1.InvalidOptionArgumentError(`Not an integer: ${value}`);
    }
    return parsedValue;
};
exports.parseInteger = parseInteger;
/**
 * argParser: Parse a string as a URL object
 */
const parseURL = (value) => {
    try {
        const url = new URL(value);
        if (!url.host) {
            throw new commander_1.InvalidOptionArgumentError(`Could not parse url ${value}`);
        }
        return url;
    }
    catch (e) {
        throw new commander_1.InvalidOptionArgumentError(`Could not parse url ${value}`);
    }
};
exports.parseURL = parseURL;
/**
 * hook: if encrypt==true and key not provided, prompt for it
 */
const promptEncryptionKey = async (thisCommand) => {
    const opts = thisCommand.opts();
    if (!opts.encrypt && opts.key) {
        return (0, helpers_1.exitWith)(1, 'Key may not be present unless encryption is used');
    }
    // if encrypt==true but we have no key, prompt for it
    if (opts.encrypt && !(opts.key && opts.key.length > 0)) {
        try {
            const answers = await inquirer_1.default.prompt([
                {
                    type: 'password',
                    message: 'Please enter an encryption key',
                    name: 'key',
                    validate(key) {
                        if (key.length > 0)
                            return true;
                        return 'Key must be present when using the encrypt option';
                    },
                },
            ]);
            opts.key = answers.key;
        }
        catch (e) {
            return (0, helpers_1.exitWith)(1, 'Failed to get encryption key');
        }
        if (!opts.key) {
            return (0, helpers_1.exitWith)(1, 'Failed to get encryption key');
        }
    }
};
exports.promptEncryptionKey = promptEncryptionKey;
/**
 * hook: require a confirmation message to be accepted unless forceOption (-f,--force) is used
 */
const getCommanderConfirmMessage = (message, { failMessage } = {}) => {
    return async (command) => {
        const confirmed = await confirmMessage(message, { force: command.opts().force });
        if (!confirmed) {
            (0, helpers_1.exitWith)(1, failMessage);
        }
    };
};
exports.getCommanderConfirmMessage = getCommanderConfirmMessage;
const confirmMessage = async (message, { force } = {}) => {
    // if we have a force option, respond yes
    if (force === true) {
        // attempt to mimic the inquirer prompt exactly
        console.log(`${chalk_1.default.green('?')} ${chalk_1.default.bold(message)} ${chalk_1.default.cyan('Yes')}`);
        return true;
    }
    const answers = await inquirer_1.default.prompt([
        {
            type: 'confirm',
            message,
            name: `confirm`,
            default: false,
        },
    ]);
    return answers.confirm;
};
exports.confirmMessage = confirmMessage;
const forceOption = new commander_1.Option('--force', `Automatically answer "yes" to all prompts, including potentially destructive requests, and run non-interactively.`);
exports.forceOption = forceOption;
//# sourceMappingURL=commander.js.map