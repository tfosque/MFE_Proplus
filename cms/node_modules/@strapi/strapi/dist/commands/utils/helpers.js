"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.notifyExperimentalCommand = exports.assertCwdContainsStrapiProject = exports.getLocalScript = exports.readableBytes = exports.ifOptions = exports.assertUrlHasProtocol = exports.exitWith = void 0;
/* eslint-disable @typescript-eslint/no-var-requires */
const chalk_1 = __importDefault(require("chalk"));
const fp_1 = require("lodash/fp");
const resolve_cwd_1 = __importDefault(require("resolve-cwd"));
const inquirer_1 = require("inquirer");
const boxen_1 = __importDefault(require("boxen"));
/**
 * Helper functions for the Strapi CLI
 */
const bytesPerKb = 1024;
const sizes = ['B ', 'KB', 'MB', 'GB', 'TB', 'PB'];
/**
 * Convert bytes to a human readable formatted string, for example "1024" becomes "1KB"
 */
const readableBytes = (bytes, decimals = 1, padStart = 0) => {
    if (!bytes) {
        return '0';
    }
    const i = Math.floor(Math.log(bytes) / Math.log(bytesPerKb));
    const result = `${parseFloat((bytes / bytesPerKb ** i).toFixed(decimals))} ${sizes[i].padStart(2)}`;
    return result.padStart(padStart);
};
exports.readableBytes = readableBytes;
/**
 *
 * Display message(s) to console and then call process.exit with code.
 * If code is zero, console.log and green text is used for messages, otherwise console.error and red text.
 *
 */
const exitWith = (code, message, options = {}) => {
    const { logger = console, prc = process } = options;
    const log = (message) => {
        if (code === 0) {
            logger.log(chalk_1.default.green(message));
        }
        else {
            logger.error(chalk_1.default.red(message));
        }
    };
    if ((0, fp_1.isString)(message)) {
        log(message);
    }
    else if ((0, fp_1.isArray)(message)) {
        message.forEach((msg) => log(msg));
    }
    prc.exit(code);
};
exports.exitWith = exitWith;
/**
 * assert that a URL object has a protocol value
 *
 */
const assertUrlHasProtocol = (url, protocol) => {
    if (!url.protocol) {
        exitWith(1, `${url.toString()} does not have a protocol`);
    }
    // if just checking for the existence of a protocol, return
    if (!protocol) {
        return;
    }
    if ((0, fp_1.isString)(protocol)) {
        if (protocol !== url.protocol) {
            exitWith(1, `${url.toString()} must have the protocol ${protocol}`);
        }
        return;
    }
    // assume an array
    if (!protocol.some((protocol) => url.protocol === protocol)) {
        return exitWith(1, `${url.toString()} must have one of the following protocols: ${protocol.join(',')}`);
    }
};
exports.assertUrlHasProtocol = assertUrlHasProtocol;
/**
 * Passes commander options to conditionCallback(). If it returns true, call isMetCallback otherwise call isNotMetCallback
 */
const ifOptions = (conditionCallback, isMetCallback = async () => { }, isNotMetCallback = async () => { }) => {
    return async (command) => {
        const opts = command.opts();
        if (await conditionCallback(opts)) {
            await isMetCallback(command);
        }
        else {
            await isNotMetCallback(command);
        }
    };
};
exports.ifOptions = ifOptions;
const assertCwdContainsStrapiProject = (name) => {
    const logErrorAndExit = () => {
        console.log(`You need to run ${chalk_1.default.yellow(`strapi ${name}`)} in a Strapi project. Make sure you are in the right directory.`);
        process.exit(1);
    };
    try {
        const pkgJSON = require(`${process.cwd()}/package.json`);
        if (!(0, fp_1.has)('dependencies.@strapi/strapi', pkgJSON) &&
            !(0, fp_1.has)('devDependencies.@strapi/strapi', pkgJSON)) {
            logErrorAndExit();
        }
    }
    catch (err) {
        logErrorAndExit();
    }
};
exports.assertCwdContainsStrapiProject = assertCwdContainsStrapiProject;
const getLocalScript = (name) => (...args) => {
    assertCwdContainsStrapiProject(name);
    const cmdPath = resolve_cwd_1.default.silent(`@strapi/strapi/dist/commands/actions/${name}/action`);
    if (!cmdPath) {
        console.log(`Error loading the local ${chalk_1.default.yellow(name)} command. Strapi might not be installed in your "node_modules". You may need to run "yarn install".`);
        process.exit(1);
    }
    const script = require(cmdPath).default;
    Promise.resolve()
        .then(() => {
        return script(...args);
    })
        .catch((error) => {
        console.error(error);
        process.exit(1);
    });
};
exports.getLocalScript = getLocalScript;
/**
 * @description Notify users this is an experimental command and get them to approve first
 * this can be opted out by passing `yes` as a property of the args object.
 *
 * @type {(args?: { force?: boolean }) => Promise<void>}
 *
 * @example
 * ```ts
 * const { notifyExperimentalCommand } = require('../utils/helpers');
 *
 * const myCommand = async ({ force }) => {
 *  await notifyExperimentalCommand({ force });
 * }
 * ```
 */
const notifyExperimentalCommand = async ({ force } = {}) => {
    console.log((0, boxen_1.default)(`The ${chalk_1.default.bold(chalk_1.default.underline('plugin:build'))} command is considered experimental, use at your own risk.`, {
        title: 'Warning',
        padding: 1,
        margin: 1,
        align: 'center',
        borderColor: 'yellow',
        borderStyle: 'bold',
    }));
    if (!force) {
        const { confirmed } = await (0, inquirer_1.prompt)({
            type: 'confirm',
            name: 'confirmed',
            message: 'Do you want to continue?',
        });
        if (!confirmed) {
            process.exit(0);
        }
    }
};
exports.notifyExperimentalCommand = notifyExperimentalCommand;
//# sourceMappingURL=helpers.js.map