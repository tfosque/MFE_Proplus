"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseExports = exports.getExportExtensionMap = exports.validateExportsOrdering = exports.validatePkg = exports.loadPkg = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const yup = __importStar(require("yup"));
/**
 * Utility functions for loading and validating package.json
 * this includes the specific validation of specific parts of
 * the package.json.
 */
/**
 * The schema for the package.json that we expect,
 * currently pretty loose.
 */
const packageJsonSchema = yup.object({
    name: yup.string().required(),
    version: yup.string().required(),
    type: yup.mixed().oneOf(['commonjs', 'module']),
    license: yup.string(),
    bin: yup.lazy((value) => typeof value === 'object'
        ? yup.object(Object.entries(value).reduce((acc, [key]) => {
            acc[key] = yup.string().required();
            return acc;
        }, {}))
        : yup.string()),
    main: yup.string(),
    module: yup.string(),
    source: yup.string(),
    types: yup.string(),
    exports: yup.lazy((value) => yup.object(typeof value === 'object'
        ? Object.entries(value).reduce((acc, [key, value]) => {
            if (typeof value === 'object') {
                acc[key] = yup
                    .object({
                    types: yup.string(),
                    source: yup.string(),
                    import: yup.string(),
                    require: yup.string(),
                    default: yup.string(),
                })
                    .noUnknown(true);
            }
            else {
                acc[key] = yup
                    .string()
                    .matches(/^\.\/.*\.json$/)
                    .required();
            }
            return acc;
        }, {})
        : undefined)),
    files: yup.array(yup.string()),
    scripts: yup.object(),
    dependencies: yup.object(),
    devDependencies: yup.object(),
    peerDependencies: yup.object(),
    engines: yup.object(),
    browserslist: yup.array(yup.string().required()),
});
/**
 * @description being a task to load the package.json starting from the current working directory
 * using a shallow find for the package.json  and `fs` to read the file. If no package.json is found,
 * the process will throw with an appropriate error message.
 *
 */
const loadPkg = async ({ cwd, logger }) => {
    const directory = path_1.default.resolve(cwd);
    const pkgPath = path_1.default.join(directory, 'package.json');
    const buffer = await promises_1.default.readFile(pkgPath).catch((err) => {
        logger.debug(err);
        throw new Error('Could not find a package.json in the current directory');
    });
    const pkg = JSON.parse(buffer.toString());
    logger.debug('Loaded package.json: \n', pkg);
    return pkg;
};
exports.loadPkg = loadPkg;
/**
 * @description validate the package.json against a standardised schema using `yup`.
 * If the validation fails, the process will throw with an appropriate error message.
 */
const validatePkg = async ({ pkg }) => {
    try {
        const validatedPkg = await packageJsonSchema.validate(pkg, {
            strict: true,
        });
        return validatedPkg;
    }
    catch (err) {
        if (err instanceof yup.ValidationError) {
            switch (err.type) {
                case 'required':
                    throw new Error(`'${err.path}' in 'package.json' is required as type '${chalk_1.default.magenta(yup.reach(packageJsonSchema, err.path ?? '').type)}'`);
                case 'matches':
                    throw new Error(`'${err.path}' in 'package.json' must be of type '${chalk_1.default.magenta(err.params?.regex)}' (recieved the value '${chalk_1.default.magenta(err.params?.value)}')`);
                /**
                 * This will only be thrown if there are keys in the export map
                 * that we don't expect so we can therefore make some assumptions
                 */
                case 'noUnknown':
                    throw new Error(`'${err.path}' in 'package.json' contains the unknown key ${chalk_1.default.magenta(err.params?.unknown)}, for compatability only the following keys are allowed: ${chalk_1.default.magenta("['types', 'source', 'import', 'require', 'default']")}`);
                default:
                    throw new Error(`'${err.path}' in 'package.json' must be of type '${chalk_1.default.magenta(err.params?.type)}' (recieved '${chalk_1.default.magenta(typeof err.params?.value)}')`);
            }
        }
        throw err;
    }
};
exports.validatePkg = validatePkg;
/**
 * @description validate the `exports` property of the package.json against a set of rules.
 * If the validation fails, the process will throw with an appropriate error message. If
 * there is no `exports` property we check the standard export-like properties on the root
 * of the package.json.
 */
const validateExportsOrdering = async ({ pkg, logger, }) => {
    if (pkg.exports) {
        const exports = Object.entries(pkg.exports);
        for (const [expPath, exp] of exports) {
            if (typeof exp === 'string') {
                // eslint-disable-next-line no-continue
                continue;
            }
            const keys = Object.keys(exp);
            if (!assertFirst('types', keys)) {
                throw new Error(`exports["${expPath}"]: the 'types' property should be the first property`);
            }
            if (!assertOrder('import', 'require', keys)) {
                logger.warn(`exports["${expPath}"]: the 'import' property should come before the 'require' property`);
            }
            if (!assertOrder('module', 'import', keys)) {
                logger.warn(`exports["${expPath}"]: the 'module' property should come before 'import' property`);
            }
            if (!assertLast('default', keys)) {
                throw new Error(`exports["${expPath}"]: the 'default' property should be the last property`);
            }
        }
    }
    else if (!['main', 'module'].some((key) => Object.prototype.hasOwnProperty.call(pkg, key))) {
        throw new Error(`'package.json' must contain a 'main' and 'module' property`);
    }
    return pkg;
};
exports.validateExportsOrdering = validateExportsOrdering;
/** @internal */
function assertFirst(key, arr) {
    const aIdx = arr.indexOf(key);
    // if not found, then we don't care
    if (aIdx === -1) {
        return true;
    }
    return aIdx === 0;
}
/** @internal */
function assertLast(key, arr) {
    const aIdx = arr.indexOf(key);
    // if not found, then we don't care
    if (aIdx === -1) {
        return true;
    }
    return aIdx === arr.length - 1;
}
/** @internal */
function assertOrder(keyA, keyB, arr) {
    const aIdx = arr.indexOf(keyA);
    const bIdx = arr.indexOf(keyB);
    // if either is not found, then we don't care
    if (aIdx === -1 || bIdx === -1) {
        return true;
    }
    return aIdx < bIdx;
}
/**
 * @internal
 */
const DEFAULT_PKG_EXT_MAP = {
    // pkg.type: "commonjs"
    commonjs: {
        cjs: '.js',
        es: '.mjs',
    },
    // pkg.type: "module"
    module: {
        cjs: '.cjs',
        es: '.js',
    },
};
/**
 * We potentially might need to support legacy exports or as package
 * development continues we have space to tweak this.
 *
 */
const getExportExtensionMap = () => {
    return DEFAULT_PKG_EXT_MAP;
};
exports.getExportExtensionMap = getExportExtensionMap;
/**
 * @internal
 *
 * @description validate the `require` and `import` properties of a given exports maps from the package.json
 * returning if any errors are found.
 *
 */
const validateExports = (_exports, options) => {
    const { extMap, pkg } = options;
    const ext = extMap[pkg.type || 'commonjs'];
    const errors = [];
    for (const exp of _exports) {
        if (exp.require && !exp.require.endsWith(ext.cjs)) {
            errors.push(`package.json with \`type: "${pkg.type}"\` - \`exports["${exp._path}"].require\` must end with "${ext.cjs}"`);
        }
        if (exp.import && !exp.import.endsWith(ext.es)) {
            errors.push(`package.json with \`type: "${pkg.type}"\` - \`exports["${exp._path}"].import\` must end with "${ext.es}"`);
        }
    }
    return errors;
};
/**
 * @description parse the exports map from the package.json into a standardised
 * format that we can use to generate build tasks from.
 */
const parseExports = ({ extMap, pkg }) => {
    const rootExport = {
        _path: '.',
        types: pkg.types,
        source: pkg.source,
        require: pkg.main,
        import: pkg.module,
        default: pkg.module || pkg.main,
    };
    const extraExports = [];
    const errors = [];
    if (pkg.exports) {
        if (!pkg.exports['./package.json']) {
            errors.push('package.json: `exports["./package.json"] must be declared.');
        }
        Object.entries(pkg.exports).forEach(([path, entry]) => {
            if (path.endsWith('.json')) {
                if (path === './package.json' && entry !== './package.json') {
                    errors.push(`package.json: 'exports["./package.json"]' must be './package.json'.`);
                }
            }
            else if (Boolean(entry) && typeof entry === 'object' && !Array.isArray(entry)) {
                if (path === '.') {
                    if (entry.require && rootExport.require && entry.require !== rootExport.require) {
                        errors.push(`package.json: mismatch between 'main' and 'exports.require'. These must be equal.`);
                    }
                    if (entry.import && rootExport.import && entry.import !== rootExport.import) {
                        errors.push(`package.json: mismatch between 'module' and 'exports.import' These must be equal.`);
                    }
                    if (entry.types && rootExport.types && entry.types !== rootExport.types) {
                        errors.push(`package.json: mismatch between 'types' and 'exports.types'. These must be equal.`);
                    }
                    if (entry.source && rootExport.source && entry.source !== rootExport.source) {
                        errors.push(`package.json: mismatch between 'source' and 'exports.source'. These must be equal.`);
                    }
                    Object.assign(rootExport, entry);
                }
                else {
                    const extraExport = {
                        _exported: true,
                        _path: path,
                        ...entry,
                    };
                    extraExports.push(extraExport);
                }
            }
            else {
                errors.push('package.json: exports must be an object');
            }
        });
    }
    const _exports = [
        /**
         * In the case of strapi plugins, we don't have a root export because we
         * ship a server side and client side package. So this can be completely omitted.
         */
        Object.values(rootExport).some((exp) => exp !== rootExport._path && Boolean(exp)) && rootExport,
        ...extraExports,
    ].filter((v) => Boolean(v));
    errors.push(...validateExports(_exports, { extMap, pkg }));
    if (errors.length) {
        throw new Error(`\n- ${errors.join('\n- ')}`);
    }
    return _exports;
};
exports.parseExports = parseExports;
//# sourceMappingURL=pkg.js.map