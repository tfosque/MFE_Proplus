"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inquirer_1 = __importDefault(require("inquirer"));
const commander_1 = require("commander");
const commander_2 = require("../commander");
const helpers_1 = require("../helpers");
const data_transfer_1 = require("../data-transfer");
const action_1 = __importDefault(require("./action"));
/**
 * `$ strapi transfer`
 */
const command = ({ command }) => {
    command
        .command('transfer')
        .description('Transfer data from one source to another')
        .allowExcessArguments(false)
        .addOption(new commander_1.Option('--from <sourceURL>', `URL of the remote Strapi instance to get data from`).argParser(commander_2.parseURL))
        .addOption(new commander_1.Option('--from-token <token>', `Transfer token for the remote Strapi source`))
        .addOption(new commander_1.Option('--to <destinationURL>', `URL of the remote Strapi instance to send data to`).argParser(commander_2.parseURL))
        .addOption(new commander_1.Option('--to-token <token>', `Transfer token for the remote Strapi destination`))
        .addOption(commander_2.forceOption)
        .addOption(data_transfer_1.excludeOption)
        .addOption(data_transfer_1.onlyOption)
        .addOption(data_transfer_1.throttleOption)
        .hook('preAction', data_transfer_1.validateExcludeOnly)
        .hook('preAction', (0, helpers_1.ifOptions)((opts) => !(opts.from || opts.to) || (opts.from && opts.to), async () => (0, helpers_1.exitWith)(1, 'Exactly one remote source (from) or destination (to) option must be provided')))
        // If --from is used, validate the URL and token
        .hook('preAction', (0, helpers_1.ifOptions)((opts) => opts.from, async (thisCommand) => {
        (0, helpers_1.assertUrlHasProtocol)(thisCommand.opts().from, ['https:', 'http:']);
        if (!thisCommand.opts().fromToken) {
            const answers = await inquirer_1.default.prompt([
                {
                    type: 'password',
                    message: 'Please enter your transfer token for the remote Strapi source',
                    name: 'fromToken',
                },
            ]);
            if (!answers.fromToken?.length) {
                (0, helpers_1.exitWith)(1, 'No token provided for remote source, aborting transfer.');
            }
            thisCommand.opts().fromToken = answers.fromToken;
        }
        await (0, commander_2.getCommanderConfirmMessage)('The transfer will delete all the local Strapi assets and its database. Are you sure you want to proceed?', { failMessage: 'Transfer process aborted' })(thisCommand);
    }))
        // If --to is used, validate the URL, token, and confirm restore
        .hook('preAction', (0, helpers_1.ifOptions)((opts) => opts.to, async (thisCommand) => {
        (0, helpers_1.assertUrlHasProtocol)(thisCommand.opts().to, ['https:', 'http:']);
        if (!thisCommand.opts().toToken) {
            const answers = await inquirer_1.default.prompt([
                {
                    type: 'password',
                    message: 'Please enter your transfer token for the remote Strapi destination',
                    name: 'toToken',
                },
            ]);
            if (!answers.toToken?.length) {
                (0, helpers_1.exitWith)(1, 'No token provided for remote destination, aborting transfer.');
            }
            thisCommand.opts().toToken = answers.toToken;
        }
        await (0, commander_2.getCommanderConfirmMessage)('The transfer will delete existing data from the remote Strapi! Are you sure you want to proceed?', { failMessage: 'Transfer process aborted' })(thisCommand);
    }))
        .action(action_1.default);
};
exports.default = command;
//# sourceMappingURL=command.js.map