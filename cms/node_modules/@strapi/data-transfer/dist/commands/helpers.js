"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readableBytes = exports.ifOptions = exports.assertUrlHasProtocol = exports.exitWith = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fp_1 = require("lodash/fp");
const bytesPerKb = 1024;
const sizes = ['B ', 'KB', 'MB', 'GB', 'TB', 'PB'];
/**
 * Convert bytes to a human readable formatted string, for example "1024" becomes "1KB"
 */
const readableBytes = (bytes, decimals = 1, padStart = 0) => {
    if (!bytes) {
        return '0';
    }
    const i = Math.floor(Math.log(bytes) / Math.log(bytesPerKb));
    const result = `${parseFloat((bytes / bytesPerKb ** i).toFixed(decimals))} ${sizes[i].padStart(2)}`;
    return result.padStart(padStart);
};
exports.readableBytes = readableBytes;
/**
 *
 * Display message(s) to console and then call process.exit with code.
 * If code is zero, console.log and green text is used for messages, otherwise console.error and red text.
 *
 */
const exitWith = (code, message, options = {}) => {
    const { logger = console, prc = process } = options;
    const log = (message) => {
        if (code === 0) {
            logger.log(chalk_1.default.green(message));
        }
        else {
            logger.error(chalk_1.default.red(message));
        }
    };
    if ((0, fp_1.isString)(message)) {
        log(message);
    }
    else if ((0, fp_1.isArray)(message)) {
        message.forEach((msg) => log(msg));
    }
    prc.exit(code);
};
exports.exitWith = exitWith;
/**
 * assert that a URL object has a protocol value
 *
 */
const assertUrlHasProtocol = (url, protocol) => {
    if (!url.protocol) {
        exitWith(1, `${url.toString()} does not have a protocol`);
    }
    // if just checking for the existence of a protocol, return
    if (!protocol) {
        return;
    }
    if ((0, fp_1.isString)(protocol)) {
        if (protocol !== url.protocol) {
            exitWith(1, `${url.toString()} must have the protocol ${protocol}`);
        }
        return;
    }
    // assume an array
    if (!protocol.some((protocol) => url.protocol === protocol)) {
        return exitWith(1, `${url.toString()} must have one of the following protocols: ${protocol.join(',')}`);
    }
};
exports.assertUrlHasProtocol = assertUrlHasProtocol;
/**
 * Passes commander options to conditionCallback(). If it returns true, call isMetCallback otherwise call isNotMetCallback
 */
const ifOptions = (conditionCallback, isMetCallback = async () => { }, isNotMetCallback = async () => { }) => {
    return async (command) => {
        const opts = command.opts();
        if (await conditionCallback(opts)) {
            await isMetCallback(command);
        }
        else {
            await isNotMetCallback(command);
        }
    };
};
exports.ifOptions = ifOptions;
//# sourceMappingURL=helpers.js.map