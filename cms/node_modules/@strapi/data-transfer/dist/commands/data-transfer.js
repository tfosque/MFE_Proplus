"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRestoreFromOptions = exports.shouldSkipStage = exports.getAssetsBackupHandler = exports.getDiffHandler = exports.setSignalHandler = exports.abortTransfer = exports.formatDiagnostic = exports.validateExcludeOnly = exports.throttleOption = exports.onlyOption = exports.exitMessageText = exports.excludeOption = exports.createStrapiInstance = exports.DEFAULT_IGNORED_CONTENT_TYPES = exports.getTransferTelemetryPayload = exports.getDefaultExportName = exports.buildTransferTable = exports.loadersFactory = void 0;
const chalk_1 = __importDefault(require("chalk"));
const cli_table3_1 = __importDefault(require("cli-table3"));
const commander_1 = require("commander");
const logger_1 = require("@strapi/logger");
const strapi_1 = __importDefault(require("@strapi/strapi"));
const ora_1 = __importDefault(require("ora"));
const fp_1 = require("lodash/fp");
const helpers_1 = require("./helpers");
const commander_2 = require("./commander");
const engineDatatransfer = __importStar(require("../engine"));
const { errors: { TransferEngineInitializationError }, } = engineDatatransfer;
const exitMessageText = (process, error = false) => {
    const processCapitalized = process[0].toUpperCase() + process.slice(1);
    if (!error) {
        return chalk_1.default.bold(chalk_1.default.green(`${processCapitalized} process has been completed successfully!`));
    }
    return chalk_1.default.bold(chalk_1.default.red(`${processCapitalized} process failed.`));
};
exports.exitMessageText = exitMessageText;
const pad = (n) => {
    return (n < 10 ? '0' : '') + String(n);
};
const yyyymmddHHMMSS = () => {
    const date = new Date();
    return (date.getFullYear() +
        pad(date.getMonth() + 1) +
        pad(date.getDate()) +
        pad(date.getHours()) +
        pad(date.getMinutes()) +
        pad(date.getSeconds()));
};
const getDefaultExportName = () => {
    return `export_${yyyymmddHHMMSS()}`;
};
exports.getDefaultExportName = getDefaultExportName;
const buildTransferTable = (resultData) => {
    if (!resultData) {
        return;
    }
    // Build pretty table
    const table = new cli_table3_1.default({
        head: ['Type', 'Count', 'Size'].map((text) => chalk_1.default.bold.blue(text)),
    });
    let totalBytes = 0;
    let totalItems = 0;
    Object.keys(resultData).forEach((stage) => {
        const item = resultData[stage];
        if (!item) {
            return;
        }
        table.push([
            { hAlign: 'left', content: chalk_1.default.bold(stage) },
            { hAlign: 'right', content: item.count },
            { hAlign: 'right', content: `${(0, helpers_1.readableBytes)(item.bytes, 1, 11)} ` },
        ]);
        totalBytes += item.bytes;
        totalItems += item.count;
        if (item.aggregates) {
            Object.keys(item.aggregates)
                .sort()
                .forEach((subkey) => {
                if (!item.aggregates) {
                    return;
                }
                const subitem = item.aggregates[subkey];
                table.push([
                    { hAlign: 'left', content: `-- ${chalk_1.default.bold.grey(subkey)}` },
                    { hAlign: 'right', content: chalk_1.default.grey(subitem.count) },
                    { hAlign: 'right', content: chalk_1.default.grey(`(${(0, helpers_1.readableBytes)(subitem.bytes, 1, 11)})`) },
                ]);
            });
        }
    });
    table.push([
        { hAlign: 'left', content: chalk_1.default.bold.green('Total') },
        { hAlign: 'right', content: chalk_1.default.bold.green(totalItems) },
        { hAlign: 'right', content: `${chalk_1.default.bold.green((0, helpers_1.readableBytes)(totalBytes, 1, 11))} ` },
    ]);
    return table;
};
exports.buildTransferTable = buildTransferTable;
const DEFAULT_IGNORED_CONTENT_TYPES = [
    'admin::permission',
    'admin::user',
    'admin::role',
    'admin::api-token',
    'admin::api-token-permission',
    'admin::transfer-token',
    'admin::transfer-token-permission',
    'admin::audit-log',
];
exports.DEFAULT_IGNORED_CONTENT_TYPES = DEFAULT_IGNORED_CONTENT_TYPES;
const abortTransfer = async ({ engine, strapi, }) => {
    try {
        await engine.abortTransfer();
        await strapi.destroy();
    }
    catch (e) {
        // ignore because there's not much else we can do
        return false;
    }
    return true;
};
exports.abortTransfer = abortTransfer;
const setSignalHandler = async (handler, signals = ['SIGINT', 'SIGTERM', 'SIGQUIT']) => {
    signals.forEach((signal) => {
        // We specifically remove ALL listeners because we have to clear the one added in Strapi bootstrap that has a process.exit
        // TODO: Ideally Strapi bootstrap would not add that listener, and then this could be more flexible and add/remove only what it needs to
        process.removeAllListeners(signal);
        process.on(signal, handler);
    });
};
exports.setSignalHandler = setSignalHandler;
const createStrapiInstance = async (opts = {}) => {
    try {
        const appContext = await strapi_1.default.compile();
        const app = (0, strapi_1.default)({ ...opts, ...appContext });
        app.log.level = opts.logLevel || 'error';
        return await app.load();
    }
    catch (error) {
        if (error instanceof Error && 'code' in error && error.code === 'ECONNREFUSED') {
            throw new Error('Process failed. Check the database connection with your Strapi project.');
        }
        throw error;
    }
};
exports.createStrapiInstance = createStrapiInstance;
const transferDataTypes = Object.keys(engineDatatransfer.TransferGroupPresets);
const throttleOption = new commander_1.Option('--throttle <delay after each entity>', `Add a delay in milliseconds between each transferred entity`)
    .argParser(commander_2.parseInteger)
    .hideHelp(); // This option is not publicly documented
exports.throttleOption = throttleOption;
const excludeOption = new commander_1.Option('--exclude <comma-separated data types>', `Exclude data using comma-separated types. Available types: ${transferDataTypes.join(',')}`).argParser((0, commander_2.getParseListWithChoices)(transferDataTypes, 'Invalid options for "exclude"'));
exports.excludeOption = excludeOption;
const onlyOption = new commander_1.Option('--only <command-separated data types>', `Include only these types of data (plus schemas). Available types: ${transferDataTypes.join(',')}`).argParser((0, commander_2.getParseListWithChoices)(transferDataTypes, 'Invalid options for "only"'));
exports.onlyOption = onlyOption;
const validateExcludeOnly = (command) => {
    const { exclude, only } = command.opts();
    if (!only || !exclude) {
        return;
    }
    const choicesInBoth = only.filter((n) => {
        return exclude.indexOf(n) !== -1;
    });
    if (choicesInBoth.length > 0) {
        (0, helpers_1.exitWith)(1, `Data types may not be used in both "exclude" and "only" in the same command. Found in both: ${choicesInBoth.join(',')}`);
    }
};
exports.validateExcludeOnly = validateExcludeOnly;
const errorColors = {
    fatal: chalk_1.default.red,
    error: chalk_1.default.red,
    silly: chalk_1.default.yellow,
};
const formatDiagnostic = (operation) => ({ details, kind }) => {
    const logger = (0, logger_1.createLogger)(logger_1.configs.createOutputFileConfiguration(`${operation}_error_log_${Date.now()}.log`));
    try {
        if (kind === 'error') {
            const { message, severity = 'fatal' } = details;
            const colorizeError = errorColors[severity];
            const errorMessage = colorizeError(`[${severity.toUpperCase()}] ${message}`);
            logger.error(errorMessage);
        }
        if (kind === 'info') {
            const { message, params } = details;
            const msg = `${message}\n${params ? JSON.stringify(params, null, 2) : ''}`;
            logger.info(msg);
        }
        if (kind === 'warning') {
            const { origin, message } = details;
            logger.warn(`(${origin ?? 'transfer'}) ${message}`);
        }
    }
    catch (err) {
        logger.error(err);
    }
};
exports.formatDiagnostic = formatDiagnostic;
const loadersFactory = (defaultLoaders = {}) => {
    const loaders = defaultLoaders;
    const updateLoader = (stage, data) => {
        if (!(stage in loaders)) {
            createLoader(stage);
        }
        const stageData = data[stage];
        const elapsedTime = stageData?.startTime
            ? (stageData?.endTime || Date.now()) - stageData.startTime
            : 0;
        const size = `size: ${(0, helpers_1.readableBytes)(stageData?.bytes ?? 0)}`;
        const elapsed = `elapsed: ${elapsedTime} ms`;
        const speed = elapsedTime > 0 ? `(${(0, helpers_1.readableBytes)(((stageData?.bytes ?? 0) * 1000) / elapsedTime)}/s)` : '';
        loaders[stage].text = `${stage}: ${stageData?.count ?? 0} transfered (${size}) (${elapsed}) ${!stageData?.endTime ? speed : ''}`;
        return loaders[stage];
    };
    const createLoader = (stage) => {
        Object.assign(loaders, { [stage]: (0, ora_1.default)() });
        return loaders[stage];
    };
    const getLoader = (stage) => {
        return loaders[stage];
    };
    return {
        updateLoader,
        createLoader,
        getLoader,
    };
};
exports.loadersFactory = loadersFactory;
/**
 * Get the telemetry data to be sent for a didDEITSProcess* event from an initialized transfer engine object
 */
const getTransferTelemetryPayload = (engine) => {
    return {
        eventProperties: {
            source: engine?.sourceProvider?.name,
            destination: engine?.destinationProvider?.name,
        },
    };
};
exports.getTransferTelemetryPayload = getTransferTelemetryPayload;
/**
 * Get a transfer engine schema diff handler that confirms with the user before bypassing a schema check
 */
const getDiffHandler = (engine, { force, action, }) => {
    return async (context, next) => {
        // if we abort here, we need to actually exit the process because of conflict with inquirer prompt
        setSignalHandler(async () => {
            await abortTransfer({ engine, strapi: strapi });
            (0, helpers_1.exitWith)(1, exitMessageText(action, true));
        });
        let workflowsStatus;
        const source = 'Schema Integrity';
        Object.entries(context.diffs).forEach(([uid, diffs]) => {
            for (const diff of diffs) {
                const path = [uid].concat(diff.path).join('.');
                const endPath = diff.path[diff.path.length - 1];
                // Catch known features
                if (uid === 'admin::workflow' ||
                    uid === 'admin::workflow-stage' ||
                    endPath?.startsWith('strapi_stage') ||
                    endPath?.startsWith('strapi_assignee')) {
                    workflowsStatus = diff.kind;
                }
                // handle generic cases
                else if (diff.kind === 'added') {
                    engine.reportWarning(chalk_1.default.red(`${chalk_1.default.bold(path)} does not exist on source`), source);
                }
                else if (diff.kind === 'deleted') {
                    engine.reportWarning(chalk_1.default.red(`${chalk_1.default.bold(path)} does not exist on destination`), source);
                }
                else if (diff.kind === 'modified') {
                    engine.reportWarning(chalk_1.default.red(`${chalk_1.default.bold(path)} has a different data type`), source);
                }
            }
        });
        // output the known feature warnings
        if (workflowsStatus === 'added') {
            engine.reportWarning(chalk_1.default.red(`Review workflows feature does not exist on source`), source);
        }
        else if (workflowsStatus === 'deleted') {
            engine.reportWarning(chalk_1.default.red(`Review workflows feature does not exist on destination`), source);
        }
        else if (workflowsStatus === 'modified') {
            engine.panic(new TransferEngineInitializationError('Unresolved differences in schema [review workflows]'));
        }
        const confirmed = await (0, commander_2.confirmMessage)('There are differences in schema between the source and destination, and the data listed above will be lost. Are you sure you want to continue?', {
            force,
        });
        // reset handler back to normal
        setSignalHandler(() => abortTransfer({ engine, strapi: strapi }));
        if (confirmed) {
            context.ignoredDiffs = (0, fp_1.merge)(context.diffs, context.ignoredDiffs);
        }
        return next(context);
    };
};
exports.getDiffHandler = getDiffHandler;
const getAssetsBackupHandler = (engine, { force, action, }) => {
    return async (context, next) => {
        // if we abort here, we need to actually exit the process because of conflict with inquirer prompt
        setSignalHandler(async () => {
            await abortTransfer({ engine, strapi: strapi });
            (0, helpers_1.exitWith)(1, exitMessageText(action, true));
        });
        console.warn('The backup for the assets could not be created inside the public directory. Ensure Strapi has write permissions on the public directory.');
        const confirmed = await (0, commander_2.confirmMessage)('Do you want to continue without backing up your public/uploads files?', {
            force,
        });
        if (confirmed) {
            context.ignore = true;
        }
        // reset handler back to normal
        setSignalHandler(() => abortTransfer({ engine, strapi: strapi }));
        return next(context);
    };
};
exports.getAssetsBackupHandler = getAssetsBackupHandler;
const shouldSkipStage = (opts, dataKind) => {
    if (opts.exclude?.includes(dataKind)) {
        return true;
    }
    if (opts.only) {
        return !opts.only.includes(dataKind);
    }
    return false;
};
exports.shouldSkipStage = shouldSkipStage;
// Based on exclude/only from options, create the restore object to match
const parseRestoreFromOptions = (opts) => {
    const entitiesOptions = {
        exclude: DEFAULT_IGNORED_CONTENT_TYPES,
        include: undefined,
    };
    // if content is not included, send an empty array for include
    if ((opts.only && !opts.only.includes('content')) || opts.exclude?.includes('content')) {
        entitiesOptions.include = [];
    }
    const restoreConfig = {
        entities: entitiesOptions,
        assets: !shouldSkipStage(opts, 'files'),
        configuration: {
            webhook: !shouldSkipStage(opts, 'config'),
            coreStore: !shouldSkipStage(opts, 'config'),
        },
    };
    return restoreConfig;
};
exports.parseRestoreFromOptions = parseRestoreFromOptions;
//# sourceMappingURL=data-transfer.js.map