"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRemoteStrapiDestinationProvider = void 0;
const crypto_1 = require("crypto");
const stream_1 = require("stream");
const fp_1 = require("lodash/fp");
const utils_1 = require("../utils");
const constants_1 = require("../../remote/constants");
const providers_1 = require("../../../errors/providers");
const jsonLength = (obj) => Buffer.byteLength(JSON.stringify(obj));
class RemoteStrapiDestinationProvider {
    name = 'destination::remote-strapi';
    type = 'destination';
    options;
    ws;
    dispatcher;
    transferID;
    constructor(options) {
        this.options = options;
        this.ws = null;
        this.dispatcher = null;
        this.transferID = null;
    }
    async initTransfer() {
        const { strategy, restore } = this.options;
        const query = this.dispatcher?.dispatchCommand({
            command: 'init',
            params: { options: { strategy, restore }, transfer: 'push' },
        });
        const res = (await query);
        if (!res?.transferID) {
            throw new providers_1.ProviderTransferError('Init failed, invalid response from the server');
        }
        return res.transferID;
    }
    #startStepOnce(stage) {
        return (0, fp_1.once)(() => this.#startStep(stage));
    }
    async #startStep(step) {
        try {
            await this.dispatcher?.dispatchTransferStep({ action: 'start', step });
        }
        catch (e) {
            if (e instanceof Error) {
                return e;
            }
            if (typeof e === 'string') {
                return new providers_1.ProviderTransferError(e);
            }
            return new providers_1.ProviderTransferError('Unexpected error');
        }
        return null;
    }
    async #endStep(step) {
        try {
            await this.dispatcher?.dispatchTransferStep({ action: 'end', step });
        }
        catch (e) {
            if (e instanceof Error) {
                return e;
            }
            if (typeof e === 'string') {
                return new providers_1.ProviderTransferError(e);
            }
            return new providers_1.ProviderTransferError('Unexpected error');
        }
        return null;
    }
    async #streamStep(step, data) {
        try {
            await this.dispatcher?.dispatchTransferStep({ action: 'stream', step, data });
        }
        catch (e) {
            if (e instanceof Error) {
                return e;
            }
            if (typeof e === 'string') {
                return new providers_1.ProviderTransferError(e);
            }
            return new providers_1.ProviderTransferError('Unexpected error');
        }
        return null;
    }
    #writeStream(step) {
        const batchSize = 1024 * 1024; // 1MB;
        const startTransferOnce = this.#startStepOnce(step);
        let batch = [];
        const batchLength = () => jsonLength(batch);
        return new stream_1.Writable({
            objectMode: true,
            final: async (callback) => {
                if (batch.length > 0) {
                    const streamError = await this.#streamStep(step, batch);
                    batch = [];
                    if (streamError) {
                        return callback(streamError);
                    }
                }
                const e = await this.#endStep(step);
                callback(e);
            },
            write: async (chunk, _encoding, callback) => {
                const startError = await startTransferOnce();
                if (startError) {
                    return callback(startError);
                }
                batch.push(chunk);
                if (batchLength() >= batchSize) {
                    const streamError = await this.#streamStep(step, batch);
                    batch = [];
                    if (streamError) {
                        return callback(streamError);
                    }
                }
                callback();
            },
        });
    }
    async bootstrap() {
        const { url, auth } = this.options;
        const validProtocols = ['https:', 'http:'];
        let ws;
        if (!validProtocols.includes(url.protocol)) {
            throw new providers_1.ProviderValidationError(`Invalid protocol "${url.protocol}"`, {
                check: 'url',
                details: {
                    protocol: url.protocol,
                    validProtocols,
                },
            });
        }
        const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${url.host}${(0, utils_1.trimTrailingSlash)(url.pathname)}${constants_1.TRANSFER_PATH}/push`;
        // No auth defined, trying public access for transfer
        if (!auth) {
            ws = await (0, utils_1.connectToWebsocket)(wsUrl);
        }
        // Common token auth, this should be the main auth method
        else if (auth.type === 'token') {
            const headers = { Authorization: `Bearer ${auth.token}` };
            ws = await (0, utils_1.connectToWebsocket)(wsUrl, { headers });
        }
        // Invalid auth method provided
        else {
            throw new providers_1.ProviderValidationError('Auth method not available', {
                check: 'auth.type',
                details: {
                    auth: auth.type,
                },
            });
        }
        this.ws = ws;
        const { retryMessageOptions } = this.options;
        this.dispatcher = (0, utils_1.createDispatcher)(this.ws, retryMessageOptions);
        this.transferID = await this.initTransfer();
        this.dispatcher.setTransferProperties({ id: this.transferID, kind: 'push' });
        await this.dispatcher.dispatchTransferAction('bootstrap');
    }
    async close() {
        // Gracefully close the remote transfer process
        if (this.transferID && this.dispatcher) {
            await this.dispatcher.dispatchTransferAction('close');
            await this.dispatcher.dispatchCommand({
                command: 'end',
                params: { transferID: this.transferID },
            });
        }
        await new Promise((resolve) => {
            const { ws } = this;
            if (!ws || ws.CLOSED) {
                resolve();
                return;
            }
            ws.on('close', () => resolve()).close();
        });
    }
    getMetadata() {
        return this.dispatcher?.dispatchTransferAction('getMetadata') ?? null;
    }
    async beforeTransfer() {
        await this.dispatcher?.dispatchTransferAction('beforeTransfer');
    }
    async rollback() {
        await this.dispatcher?.dispatchTransferAction('rollback');
    }
    getSchemas() {
        if (!this.dispatcher) {
            return Promise.resolve(null);
        }
        return this.dispatcher.dispatchTransferAction('getSchemas');
    }
    createEntitiesWriteStream() {
        return this.#writeStream('entities');
    }
    createLinksWriteStream() {
        return this.#writeStream('links');
    }
    createConfigurationWriteStream() {
        return this.#writeStream('configuration');
    }
    createAssetsWriteStream() {
        let batch = [];
        let hasStarted = false;
        const batchSize = 1024 * 1024; // 1MB;
        const batchLength = () => {
            return batch.reduce((acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc), 0);
        };
        const startAssetsTransferOnce = this.#startStepOnce('assets');
        const flush = async () => {
            const streamError = await this.#streamStep('assets', batch);
            batch = [];
            return streamError;
        };
        const safePush = async (chunk) => {
            batch.push(chunk);
            if (batchLength() >= batchSize) {
                const streamError = await flush();
                if (streamError) {
                    throw streamError;
                }
            }
        };
        return new stream_1.Writable({
            objectMode: true,
            final: async (callback) => {
                if (batch.length > 0) {
                    await flush();
                }
                if (hasStarted) {
                    const endStepError = await this.#endStep('assets');
                    if (endStepError) {
                        return callback(endStepError);
                    }
                }
                return callback(null);
            },
            async write(asset, _encoding, callback) {
                const startError = await startAssetsTransferOnce();
                if (startError) {
                    return callback(startError);
                }
                hasStarted = true;
                const assetID = (0, crypto_1.randomUUID)();
                const { filename, filepath, stats, stream, metadata } = asset;
                try {
                    await safePush({
                        action: 'start',
                        assetID,
                        data: { filename, filepath, stats, metadata },
                    });
                    for await (const chunk of stream) {
                        await safePush({ action: 'stream', assetID, data: chunk });
                    }
                    await safePush({ action: 'end', assetID });
                    callback();
                }
                catch (error) {
                    if (error instanceof Error) {
                        callback(error);
                    }
                }
            },
        });
    }
}
const createRemoteStrapiDestinationProvider = (options) => {
    return new RemoteStrapiDestinationProvider(options);
};
exports.createRemoteStrapiDestinationProvider = createRemoteStrapiDestinationProvider;
//# sourceMappingURL=index.js.map