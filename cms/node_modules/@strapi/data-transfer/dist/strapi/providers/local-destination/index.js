"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLocalStrapiDestinationProvider = exports.DEFAULT_CONFLICT_STRATEGY = exports.VALID_CONFLICT_STRATEGIES = void 0;
const stream_1 = require("stream");
const path_1 = __importDefault(require("path"));
const fse = __importStar(require("fs-extra"));
const strategies_1 = require("./strategies");
const utils = __importStar(require("../../../utils"));
const providers_1 = require("../../../errors/providers");
const providers_2 = require("../../../utils/providers");
exports.VALID_CONFLICT_STRATEGIES = ['restore'];
exports.DEFAULT_CONFLICT_STRATEGY = 'restore';
class LocalStrapiDestinationProvider {
    name = 'destination::local-strapi';
    type = 'destination';
    options;
    strapi;
    transaction;
    uploadsBackupDirectoryName;
    /**
     * The entities mapper is used to map old entities to their new IDs
     */
    #entitiesMapper;
    constructor(options) {
        this.options = options;
        this.#entitiesMapper = {};
        this.uploadsBackupDirectoryName = `uploads_backup_${Date.now()}`;
    }
    async bootstrap() {
        this.#validateOptions();
        this.strapi = await this.options.getStrapi();
        if (!this.strapi) {
            throw new providers_1.ProviderInitializationError('Could not access local strapi');
        }
        this.transaction = utils.transaction.createTransaction(this.strapi);
    }
    // TODO: either move this to restore strategy, or restore strategy should given access to these instead of repeating the logic possibly in a different way
    #areAssetsIncluded = () => {
        return this.options.restore?.assets;
    };
    #isContentTypeIncluded = (type) => {
        const notIncluded = this.options.restore?.entities?.include &&
            !this.options.restore?.entities?.include?.includes(type);
        const excluded = this.options.restore?.entities?.exclude &&
            this.options.restore?.entities.exclude.includes(type);
        return !excluded && !notIncluded;
    };
    async close() {
        const { autoDestroy } = this.options;
        this.transaction?.end();
        // Basically `!== false` but more deterministic
        if (autoDestroy === undefined || autoDestroy === true) {
            await this.strapi?.destroy();
        }
    }
    #validateOptions() {
        if (!exports.VALID_CONFLICT_STRATEGIES.includes(this.options.strategy)) {
            throw new providers_1.ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {
                check: 'strategy',
                strategy: this.options.strategy,
                validStrategies: exports.VALID_CONFLICT_STRATEGIES,
            });
        }
        // require restore options when using restore
        if (this.options.strategy === 'restore' && !this.options.restore) {
            throw new providers_1.ProviderValidationError('Missing restore options');
        }
    }
    async #deleteFromRestoreOptions() {
        (0, providers_2.assertValidStrapi)(this.strapi);
        if (!this.options.restore) {
            throw new providers_1.ProviderValidationError('Missing restore options');
        }
        return strategies_1.restore.deleteRecords(this.strapi, this.options.restore);
    }
    async #deleteAllAssets(trx) {
        (0, providers_2.assertValidStrapi)(this.strapi);
        // if we're not restoring files, don't touch the files
        if (!this.#areAssetsIncluded()) {
            return;
        }
        const stream = this.strapi.db
            // Create a query builder instance (default type is 'select')
            .queryBuilder('plugin::upload.file')
            // Fetch all columns
            .select('*')
            // Attach the transaction
            .transacting(trx)
            // Get a readable stream
            .stream();
        // TODO use bulk delete when exists in providers
        for await (const file of stream) {
            await this.strapi.plugin('upload').provider.delete(file);
            if (file.formats) {
                for (const fileFormat of Object.values(file.formats)) {
                    await this.strapi.plugin('upload').provider.delete(fileFormat);
                }
            }
        }
    }
    async rollback() {
        await this.transaction?.rollback();
    }
    async beforeTransfer() {
        if (!this.strapi) {
            throw new Error('Strapi instance not found');
        }
        await this.transaction?.attach(async (trx) => {
            try {
                if (this.options.strategy === 'restore') {
                    await this.#handleAssetsBackup();
                    await this.#deleteAllAssets(trx);
                    await this.#deleteFromRestoreOptions();
                }
            }
            catch (error) {
                throw new Error(`restore failed ${error}`);
            }
        });
    }
    getMetadata() {
        (0, providers_2.assertValidStrapi)(this.strapi, 'Not able to get Schemas');
        const strapiVersion = this.strapi.config.get('info.strapi');
        const createdAt = new Date().toISOString();
        return {
            createdAt,
            strapi: {
                version: strapiVersion,
            },
        };
    }
    getSchemas() {
        (0, providers_2.assertValidStrapi)(this.strapi, 'Not able to get Schemas');
        const schemas = {
            ...this.strapi.contentTypes,
            ...this.strapi.components,
        };
        return utils.schema.mapSchemasValues(schemas);
    }
    createEntitiesWriteStream() {
        (0, providers_2.assertValidStrapi)(this.strapi, 'Not able to import entities');
        const { strategy } = this.options;
        const updateMappingTable = (type, oldID, newID) => {
            if (!this.#entitiesMapper[type]) {
                this.#entitiesMapper[type] = {};
            }
            Object.assign(this.#entitiesMapper[type], { [oldID]: newID });
        };
        if (strategy === 'restore') {
            return strategies_1.restore.createEntitiesWriteStream({
                strapi: this.strapi,
                updateMappingTable,
                transaction: this.transaction,
            });
        }
        throw new providers_1.ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {
            check: 'strategy',
            strategy: this.options.strategy,
            validStrategies: exports.VALID_CONFLICT_STRATEGIES,
        });
    }
    async #handleAssetsBackup() {
        (0, providers_2.assertValidStrapi)(this.strapi, 'Not able to create the assets backup');
        // if we're not restoring assets, don't back them up because they won't be touched
        if (!this.#areAssetsIncluded()) {
            return;
        }
        if (this.strapi.config.get('plugin.upload').provider === 'local') {
            const assetsDirectory = path_1.default.join(this.strapi.dirs.static.public, 'uploads');
            const backupDirectory = path_1.default.join(this.strapi.dirs.static.public, this.uploadsBackupDirectoryName);
            try {
                // Check access before attempting to do anything
                await fse.access(assetsDirectory, 
                // eslint-disable-next-line no-bitwise
                fse.constants.W_OK | fse.constants.R_OK | fse.constants.F_OK);
                // eslint-disable-next-line no-bitwise
                await fse.access(path_1.default.join(assetsDirectory, '..'), fse.constants.W_OK | fse.constants.R_OK);
                await fse.move(assetsDirectory, backupDirectory);
                await fse.mkdir(assetsDirectory);
                // Create a .gitkeep file to ensure the directory is not empty
                await fse.outputFile(path_1.default.join(assetsDirectory, '.gitkeep'), '');
            }
            catch (err) {
                throw new providers_1.ProviderTransferError('The backup folder for the assets could not be created inside the public folder. Please ensure Strapi has write permissions on the public directory', {
                    code: 'ASSETS_DIRECTORY_ERR',
                });
            }
            return backupDirectory;
        }
    }
    async #removeAssetsBackup() {
        (0, providers_2.assertValidStrapi)(this.strapi, 'Not able to remove Assets');
        // if we're not restoring assets, don't back them up because they won't be touched
        if (!this.#areAssetsIncluded()) {
            return;
        }
        // TODO: this should catch all thrown errors and bubble it up to engine so it can be reported as a non-fatal diagnostic message telling the user they may need to manually delete assets
        if (this.strapi.config.get('plugin.upload').provider === 'local') {
            (0, providers_2.assertValidStrapi)(this.strapi);
            const backupDirectory = path_1.default.join(this.strapi.dirs.static.public, this.uploadsBackupDirectoryName);
            await fse.rm(backupDirectory, { recursive: true, force: true });
        }
    }
    // TODO: Move this logic to the restore strategy
    async createAssetsWriteStream() {
        (0, providers_2.assertValidStrapi)(this.strapi, 'Not able to stream Assets');
        if (!this.#areAssetsIncluded()) {
            throw new providers_1.ProviderTransferError('Attempting to transfer assets when they are not included');
        }
        const removeAssetsBackup = this.#removeAssetsBackup.bind(this);
        const strapi = this.strapi;
        const transaction = this.transaction;
        const backupDirectory = this.uploadsBackupDirectoryName;
        const restoreMediaEntitiesContent = this.#isContentTypeIncluded('plugin::upload.file');
        return new stream_1.Writable({
            objectMode: true,
            async final(next) {
                // Delete the backup folder
                await removeAssetsBackup();
                next();
            },
            async write(chunk, _encoding, callback) {
                await transaction?.attach(async () => {
                    // TODO: Remove this logic in V5
                    if (!chunk.metadata) {
                        // If metadata does not exist is because it is an old backup file
                        const assetsDirectory = path_1.default.join(strapi.dirs.static.public, 'uploads');
                        const entryPath = path_1.default.join(assetsDirectory, chunk.filename);
                        const writableStream = fse.createWriteStream(entryPath);
                        chunk.stream
                            .pipe(writableStream)
                            .on('close', () => {
                            callback(null);
                        })
                            .on('error', async (error) => {
                            const errorMessage = error.code === 'ENOSPC'
                                ? " Your server doesn't have space to proceed with the import. "
                                : ' ';
                            try {
                                await fse.rm(assetsDirectory, { recursive: true, force: true });
                                this.destroy(new providers_1.ProviderTransferError(`There was an error during the transfer process.${errorMessage}The original files have been restored to ${assetsDirectory}`));
                            }
                            catch (err) {
                                throw new providers_1.ProviderTransferError(`There was an error doing the rollback process. The original files are in ${backupDirectory}, but we failed to restore them to ${assetsDirectory}`);
                            }
                            finally {
                                callback(error);
                            }
                        });
                        return;
                    }
                    const uploadData = {
                        ...chunk.metadata,
                        stream: stream_1.Readable.from(chunk.stream),
                        buffer: chunk?.buffer,
                    };
                    const provider = strapi.config.get('plugin.upload').provider;
                    try {
                        await strapi.plugin('upload').provider.uploadStream(uploadData);
                        // if we're not supposed to transfer the associated entities, stop here
                        if (!restoreMediaEntitiesContent) {
                            return callback();
                        }
                        // Files formats are stored within the parent file entity
                        if (uploadData?.type) {
                            const entry = await strapi.db.query('plugin::upload.file').findOne({
                                where: { hash: uploadData.mainHash },
                            });
                            const specificFormat = entry?.formats?.[uploadData.type];
                            if (specificFormat) {
                                specificFormat.url = uploadData.url;
                            }
                            await strapi.db.query('plugin::upload.file').update({
                                where: { hash: uploadData.mainHash },
                                data: {
                                    formats: entry.formats,
                                    provider,
                                },
                            });
                            return callback();
                        }
                        const entry = await strapi.db.query('plugin::upload.file').findOne({
                            where: { hash: uploadData.hash },
                        });
                        entry.url = uploadData.url;
                        await strapi.db.query('plugin::upload.file').update({
                            where: { hash: uploadData.hash },
                            data: {
                                url: entry.url,
                                provider,
                            },
                        });
                        callback();
                    }
                    catch (error) {
                        callback(new Error(`Error while uploading asset ${chunk.filename} ${error}`));
                    }
                });
            },
        });
    }
    async createConfigurationWriteStream() {
        (0, providers_2.assertValidStrapi)(this.strapi, 'Not able to stream Configurations');
        const { strategy } = this.options;
        if (strategy === 'restore') {
            return strategies_1.restore.createConfigurationWriteStream(this.strapi, this.transaction);
        }
        throw new providers_1.ProviderValidationError(`Invalid strategy ${strategy}`, {
            check: 'strategy',
            strategy,
            validStrategies: exports.VALID_CONFLICT_STRATEGIES,
        });
    }
    async createLinksWriteStream() {
        if (!this.strapi) {
            throw new Error('Not able to stream links. Strapi instance not found');
        }
        const { strategy } = this.options;
        const mapID = (uid, id) => this.#entitiesMapper[uid]?.[id];
        if (strategy === 'restore') {
            return strategies_1.restore.createLinksWriteStream(mapID, this.strapi, this.transaction);
        }
        throw new providers_1.ProviderValidationError(`Invalid strategy ${strategy}`, {
            check: 'strategy',
            strategy,
            validStrategies: exports.VALID_CONFLICT_STRATEGIES,
        });
    }
}
const createLocalStrapiDestinationProvider = (options) => {
    return new LocalStrapiDestinationProvider(options);
};
exports.createLocalStrapiDestinationProvider = createLocalStrapiDestinationProvider;
//# sourceMappingURL=index.js.map