"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLocalFileDestinationProvider = void 0;
const path_1 = __importDefault(require("path"));
const zlib_1 = __importDefault(require("zlib"));
const stream_1 = require("stream");
const fs_extra_1 = require("fs-extra");
const tar_stream_1 = __importDefault(require("tar-stream"));
const Stringer_1 = require("stream-json/jsonl/Stringer");
const stream_chain_1 = require("stream-chain");
const encryption_1 = require("../../../utils/encryption");
const utils_1 = require("./utils");
const providers_1 = require("../../../errors/providers");
const createLocalFileDestinationProvider = (options) => {
    return new LocalFileDestinationProvider(options);
};
exports.createLocalFileDestinationProvider = createLocalFileDestinationProvider;
class LocalFileDestinationProvider {
    name = 'destination::local-file';
    type = 'destination';
    options;
    results = {};
    #providersMetadata = {};
    #archive = {};
    constructor(options) {
        this.options = options;
    }
    get #archivePath() {
        const { encryption, compression, file } = this.options;
        let filePath = `${file.path}.tar`;
        if (compression.enabled) {
            filePath += '.gz';
        }
        if (encryption.enabled) {
            filePath += '.enc';
        }
        return filePath;
    }
    setMetadata(target, metadata) {
        this.#providersMetadata[target] = metadata;
        return this;
    }
    createGzip() {
        return zlib_1.default.createGzip();
    }
    bootstrap() {
        const { compression, encryption } = this.options;
        if (encryption.enabled && !encryption.key) {
            throw new Error("Can't encrypt without a key");
        }
        this.#archive.stream = tar_stream_1.default.pack();
        const outStream = (0, fs_extra_1.createWriteStream)(this.#archivePath);
        outStream.on('error', (err) => {
            if (err.code === 'ENOSPC') {
                throw new providers_1.ProviderTransferError("Your server doesn't have space to proceed with the import.");
            }
            throw err;
        });
        const archiveTransforms = [];
        if (compression.enabled) {
            archiveTransforms.push(this.createGzip());
        }
        if (encryption.enabled && encryption.key) {
            archiveTransforms.push((0, encryption_1.createEncryptionCipher)(encryption.key));
        }
        this.#archive.pipeline = (0, stream_chain_1.chain)([this.#archive.stream, ...archiveTransforms, outStream]);
        this.results.file = { path: this.#archivePath };
    }
    async close() {
        const { stream, pipeline } = this.#archive;
        if (!stream) {
            return;
        }
        await this.#writeMetadata();
        stream.finalize();
        if (pipeline && !pipeline.closed) {
            await new Promise((resolve, reject) => {
                pipeline.on('close', resolve).on('error', reject);
            });
        }
    }
    async rollback() {
        await this.close();
        await (0, fs_extra_1.rm)(this.#archivePath, { force: true });
    }
    getMetadata() {
        return null;
    }
    async #writeMetadata() {
        const metadata = this.#providersMetadata.source;
        if (metadata) {
            await new Promise((resolve) => {
                const outStream = this.#getMetadataStream();
                const data = JSON.stringify(metadata, null, 2);
                stream_1.Readable.from(data).pipe(outStream).on('close', resolve);
            });
        }
    }
    #getMetadataStream() {
        const { stream } = this.#archive;
        if (!stream) {
            throw new Error('Archive stream is unavailable');
        }
        return (0, utils_1.createTarEntryStream)(stream, () => 'metadata.json');
    }
    createSchemasWriteStream() {
        if (!this.#archive.stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = (0, utils_1.createFilePathFactory)('schemas');
        const entryStream = (0, utils_1.createTarEntryStream)(this.#archive.stream, filePathFactory, this.options.file.maxSizeJsonl);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
    createEntitiesWriteStream() {
        if (!this.#archive.stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = (0, utils_1.createFilePathFactory)('entities');
        const entryStream = (0, utils_1.createTarEntryStream)(this.#archive.stream, filePathFactory, this.options.file.maxSizeJsonl);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
    createLinksWriteStream() {
        if (!this.#archive.stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = (0, utils_1.createFilePathFactory)('links');
        const entryStream = (0, utils_1.createTarEntryStream)(this.#archive.stream, filePathFactory, this.options.file.maxSizeJsonl);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
    createConfigurationWriteStream() {
        if (!this.#archive.stream) {
            throw new Error('Archive stream is unavailable');
        }
        const filePathFactory = (0, utils_1.createFilePathFactory)('configuration');
        const entryStream = (0, utils_1.createTarEntryStream)(this.#archive.stream, filePathFactory, this.options.file.maxSizeJsonl);
        return (0, stream_chain_1.chain)([(0, Stringer_1.stringer)(), entryStream]);
    }
    createAssetsWriteStream() {
        const { stream: archiveStream } = this.#archive;
        if (!archiveStream) {
            throw new Error('Archive stream is unavailable');
        }
        return new stream_1.Writable({
            objectMode: true,
            write(data, _encoding, callback) {
                // always write tar files with posix paths so we have a standard format for paths regardless of system
                const entryPath = path_1.default.posix.join('assets', 'uploads', data.filename);
                const entryMetadataPath = path_1.default.posix.join('assets', 'metadata', `${data.filename}.json`);
                const stringifiedMetadata = JSON.stringify(data.metadata);
                archiveStream.entry({
                    name: entryMetadataPath,
                    size: stringifiedMetadata.length,
                }, stringifiedMetadata);
                const entry = archiveStream.entry({
                    name: entryPath,
                    size: data.stats.size,
                });
                if (!entry) {
                    callback(new Error(`Failed to created an asset tar entry for ${entryPath}`));
                    return;
                }
                data.stream.pipe(entry);
                entry
                    .on('finish', () => {
                    callback(null);
                })
                    .on('error', (error) => {
                    callback(error);
                });
            },
        });
    }
}
//# sourceMappingURL=index.js.map