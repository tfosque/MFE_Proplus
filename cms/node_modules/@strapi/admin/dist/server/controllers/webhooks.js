"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@strapi/utils");
const urlRegex = /^(?:([a-z0-9+.-]+):\/\/)(?:\S+(?::\S*)?@)?(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9_]-*)*[a-z\u00a1-\uffff0-9_]+)(?:\.(?:[a-z\u00a1-\uffff0-9_]-*)*[a-z\u00a1-\uffff0-9_]+)*\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/;
const webhookValidator = utils_1.yup
    .object({
    name: utils_1.yup.string().required(),
    url: utils_1.yup.string().matches(urlRegex, 'url must be a valid URL').required(),
    headers: utils_1.yup.lazy((data) => {
        if (typeof data !== 'object') {
            return utils_1.yup.object().required();
        }
        return utils_1.yup
            .object(
        // @ts-expect-error
        lodash_1.default.mapValues(data, () => {
            utils_1.yup.string().min(1).required();
        }))
            .required();
    }),
    events: utils_1.yup.array().of(utils_1.yup.string()).required(),
})
    .noUnknown();
const updateWebhookValidator = webhookValidator.shape({
    isEnabled: utils_1.yup.boolean(),
});
exports.default = {
    async listWebhooks(ctx) {
        const webhooks = await strapi.webhookStore.findWebhooks();
        ctx.send({ data: webhooks });
    },
    async getWebhook(ctx) {
        const { id } = ctx.params;
        const webhook = await strapi.webhookStore.findWebhook(id);
        if (!webhook) {
            return ctx.notFound('webhook.notFound');
        }
        ctx.send({ data: webhook });
    },
    async createWebhook(ctx) {
        const { body } = ctx.request;
        await (0, utils_1.validateYupSchema)(webhookValidator)(body);
        const webhook = await strapi.webhookStore.createWebhook(body);
        strapi.webhookRunner.add(webhook);
        ctx.created({ data: webhook });
    },
    async updateWebhook(ctx) {
        const { id } = ctx.params;
        const { body } = ctx.request;
        await (0, utils_1.validateYupSchema)(updateWebhookValidator)(body);
        const webhook = await strapi.webhookStore.findWebhook(id);
        if (!webhook) {
            return ctx.notFound('webhook.notFound');
        }
        const updatedWebhook = await strapi.webhookStore.updateWebhook(id, {
            ...webhook,
            ...body,
        });
        if (!updatedWebhook) {
            return ctx.notFound('webhook.notFound');
        }
        strapi.webhookRunner.update(updatedWebhook);
        ctx.send({ data: updatedWebhook });
    },
    async deleteWebhook(ctx) {
        const { id } = ctx.params;
        const webhook = await strapi.webhookStore.findWebhook(id);
        if (!webhook) {
            return ctx.notFound('webhook.notFound');
        }
        await strapi.webhookStore.deleteWebhook(id);
        strapi.webhookRunner.remove(webhook);
        ctx.body = { data: webhook };
    },
    async deleteWebhooks(ctx) {
        const { ids } = ctx.request.body;
        if (!Array.isArray(ids) || ids.length === 0) {
            return ctx.badRequest('ids must be an array of id');
        }
        for (const id of ids) {
            const webhook = await strapi.webhookStore.findWebhook(id);
            if (webhook) {
                await strapi.webhookStore.deleteWebhook(id);
                strapi.webhookRunner.remove(webhook);
            }
        }
        ctx.send({ data: ids });
    },
    async triggerWebhook(ctx) {
        const { id } = ctx.params;
        const webhook = (await strapi.webhookStore.findWebhook(id));
        const response = await strapi.webhookRunner.run(webhook, 'trigger-test', {});
        ctx.body = { data: response };
    },
};
//# sourceMappingURL=webhooks.js.map