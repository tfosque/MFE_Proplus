"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const utils_1 = require("@strapi/utils");
const user_1 = require("../validation/user");
const utils_2 = require("../utils");
const { ApplicationError } = utils_1.errors;
exports.default = {
    async create(ctx) {
        const { body } = ctx.request;
        const cleanData = { ...body, email: _.get(body, `email`, ``).toLowerCase() };
        await (0, user_1.validateUserCreationInput)(cleanData);
        const attributes = _.pick(cleanData, [
            'firstname',
            'lastname',
            'email',
            'roles',
            'preferedLanguage',
        ]);
        const userAlreadyExists = await (0, utils_2.getService)('user').exists({
            email: attributes.email,
        });
        if (userAlreadyExists) {
            throw new ApplicationError('Email already taken');
        }
        const createdUser = await (0, utils_2.getService)('user').create(attributes);
        const userInfo = (0, utils_2.getService)('user').sanitizeUser(createdUser);
        // Note: We need to assign manually the registrationToken to the
        // final user payload so that it's not removed in the sanitation process.
        Object.assign(userInfo, { registrationToken: createdUser.registrationToken });
        // Send 201 created
        ctx.created({ data: userInfo });
    },
    async find(ctx) {
        const userService = (0, utils_2.getService)('user');
        const permissionsManager = strapi.admin.services.permission.createPermissionsManager({
            ability: ctx.state.userAbility,
            model: 'admin::user',
        });
        await permissionsManager.validateQuery(ctx.query);
        const sanitizedQuery = await permissionsManager.sanitizeQuery(ctx.query);
        const { results, pagination } = await userService.findPage(sanitizedQuery);
        ctx.body = {
            data: {
                results: results.map((user) => userService.sanitizeUser(user)),
                pagination,
            },
        };
    },
    async findOne(ctx) {
        const { id } = ctx.params;
        const user = await (0, utils_2.getService)('user').findOne(id);
        if (!user) {
            return ctx.notFound('User does not exist');
        }
        ctx.body = {
            data: (0, utils_2.getService)('user').sanitizeUser(user),
        };
    },
    async update(ctx) {
        const { id } = ctx.params;
        const { body: input } = ctx.request;
        await (0, user_1.validateUserUpdateInput)(input);
        if (_.has(input, 'email')) {
            const uniqueEmailCheck = await (0, utils_2.getService)('user').exists({
                id: { $ne: id },
                email: input.email,
            });
            if (uniqueEmailCheck) {
                throw new ApplicationError('A user with this email address already exists');
            }
        }
        const updatedUser = await (0, utils_2.getService)('user').updateById(id, input);
        if (!updatedUser) {
            return ctx.notFound('User does not exist');
        }
        ctx.body = {
            data: (0, utils_2.getService)('user').sanitizeUser(updatedUser),
        };
    },
    async deleteOne(ctx) {
        const { id } = ctx.params;
        const deletedUser = await (0, utils_2.getService)('user').deleteById(id);
        if (!deletedUser) {
            return ctx.notFound('User not found');
        }
        return ctx.deleted({
            data: (0, utils_2.getService)('user').sanitizeUser(deletedUser),
        });
    },
    /**
     * Delete several users
     * @param {KoaContext} ctx - koa context
     */
    async deleteMany(ctx) {
        const { body } = ctx.request;
        await (0, user_1.validateUsersDeleteInput)(body);
        const users = await (0, utils_2.getService)('user').deleteByIds(body.ids);
        const sanitizedUsers = users.map((0, utils_2.getService)('user').sanitizeUser);
        return ctx.deleted({
            data: sanitizedUsers,
        });
    },
};
//# sourceMappingURL=user.js.map