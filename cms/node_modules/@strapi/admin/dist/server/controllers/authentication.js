"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-expect-error
const koa_passport_1 = __importDefault(require("koa-passport"));
const koa_compose_1 = __importDefault(require("koa-compose"));
const utils_1 = require("@strapi/utils");
const utils_2 = require("../utils");
const authentication_1 = require("../validation/authentication");
const { ApplicationError, ValidationError } = utils_1.errors;
exports.default = {
    login: (0, koa_compose_1.default)([
        (ctx, next) => {
            return koa_passport_1.default.authenticate('local', { session: false }, (err, user, info) => {
                if (err) {
                    strapi.eventHub.emit('admin.auth.error', { error: err, provider: 'local' });
                    // if this is a recognized error, allow it to bubble up to user
                    if (err.details?.code === 'LOGIN_NOT_ALLOWED') {
                        throw err;
                    }
                    // for all other errors throw a generic error to prevent leaking info
                    return ctx.notImplemented();
                }
                if (!user) {
                    strapi.eventHub.emit('admin.auth.error', {
                        error: new Error(info.message),
                        provider: 'local',
                    });
                    throw new ApplicationError(info.message);
                }
                ctx.state.user = user;
                const sanitizedUser = (0, utils_2.getService)('user').sanitizeUser(user);
                strapi.eventHub.emit('admin.auth.success', { user: sanitizedUser, provider: 'local' });
                return next();
            })(ctx, next);
        },
        (ctx) => {
            const { user } = ctx.state;
            ctx.body = {
                data: {
                    token: (0, utils_2.getService)('token').createJwtToken(user),
                    user: (0, utils_2.getService)('user').sanitizeUser(ctx.state.user), // TODO: fetch more detailed info
                },
            };
        },
    ]),
    async renewToken(ctx) {
        await (0, authentication_1.validateRenewTokenInput)(ctx.request.body);
        const { token } = ctx.request.body;
        const { isValid, payload } = (0, utils_2.getService)('token').decodeJwtToken(token);
        if (!isValid) {
            throw new ValidationError('Invalid token');
        }
        ctx.body = {
            data: {
                token: (0, utils_2.getService)('token').createJwtToken({ id: payload.id }),
            },
        };
    },
    async registrationInfo(ctx) {
        await (0, authentication_1.validateRegistrationInfoQuery)(ctx.request.query);
        const { registrationToken } = ctx.request.query;
        const registrationInfo = await (0, utils_2.getService)('user').findRegistrationInfo(registrationToken);
        if (!registrationInfo) {
            throw new ValidationError('Invalid registrationToken');
        }
        ctx.body = { data: registrationInfo };
    },
    async register(ctx) {
        const input = ctx.request.body;
        await (0, authentication_1.validateRegistrationInput)(input);
        const user = await (0, utils_2.getService)('user').register(input);
        ctx.body = {
            data: {
                token: (0, utils_2.getService)('token').createJwtToken(user),
                user: (0, utils_2.getService)('user').sanitizeUser(user),
            },
        };
    },
    async registerAdmin(ctx) {
        const input = ctx.request.body;
        await (0, authentication_1.validateAdminRegistrationInput)(input);
        const hasAdmin = await (0, utils_2.getService)('user').exists();
        if (hasAdmin) {
            throw new ApplicationError('You cannot register a new super admin');
        }
        const superAdminRole = await (0, utils_2.getService)('role').getSuperAdmin();
        if (!superAdminRole) {
            throw new ApplicationError("Cannot register the first admin because the super admin role doesn't exist.");
        }
        const user = await (0, utils_2.getService)('user').create({
            ...input,
            registrationToken: null,
            isActive: true,
            roles: superAdminRole ? [superAdminRole.id] : [],
        });
        strapi.telemetry.send('didCreateFirstAdmin');
        ctx.body = {
            data: {
                token: (0, utils_2.getService)('token').createJwtToken(user),
                user: (0, utils_2.getService)('user').sanitizeUser(user),
            },
        };
    },
    async forgotPassword(ctx) {
        const input = ctx.request.body;
        await (0, authentication_1.validateForgotPasswordInput)(input);
        (0, utils_2.getService)('auth').forgotPassword(input);
        ctx.status = 204;
    },
    async resetPassword(ctx) {
        const input = ctx.request.body;
        await (0, authentication_1.validateResetPasswordInput)(input);
        const user = await (0, utils_2.getService)('auth').resetPassword(input);
        ctx.body = {
            data: {
                token: (0, utils_2.getService)('token').createJwtToken(user),
                user: (0, utils_2.getService)('user').sanitizeUser(user),
            },
        };
    },
    logout(ctx) {
        const sanitizedUser = (0, utils_2.getService)('user').sanitizeUser(ctx.state.user);
        strapi.eventHub.emit('admin.logout', { user: sanitizedUser });
        ctx.body = { data: {} };
    },
};
//# sourceMappingURL=authentication.js.map