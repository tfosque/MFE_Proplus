"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePermissions = exports.permission = exports.permissionsAreEquals = exports.arrayOfConditionNames = exports.roles = exports.password = exports.username = exports.lastname = exports.firstname = exports.email = void 0;
const utils_1 = require("@strapi/utils");
const lodash_1 = __importDefault(require("lodash"));
const fp_1 = require("lodash/fp");
const utils_2 = require("../utils");
const action_1 = __importDefault(require("../domain/action"));
const common_functions_1 = require("./common-functions");
const getActionFromProvider = (actionId) => {
    return (0, utils_2.getService)('permission').actionProvider.get(actionId);
};
exports.email = utils_1.yup.string().email().lowercase();
exports.firstname = utils_1.yup.string().trim().min(1);
exports.lastname = utils_1.yup.string();
exports.username = utils_1.yup.string().min(1);
exports.password = utils_1.yup
    .string()
    .min(8)
    .matches(/[a-z]/, '${path} must contain at least one lowercase character')
    .matches(/[A-Z]/, '${path} must contain at least one uppercase character')
    .matches(/\d/, '${path} must contain at least one number');
exports.roles = utils_1.yup.array(utils_1.yup.strapiID()).min(1);
const isAPluginName = utils_1.yup
    .string()
    .test('is-a-plugin-name', 'is not a plugin name', function (value) {
    return [undefined, 'admin', ...Object.keys(strapi.plugins)].includes(value)
        ? true
        : this.createError({ path: this.path, message: `${this.path} is not an existing plugin` });
});
exports.arrayOfConditionNames = utils_1.yup
    .array()
    .of(utils_1.yup.string())
    .test('is-an-array-of-conditions', 'is not a plugin name', function (value) {
    const ids = strapi.admin.services.permission.conditionProvider.keys();
    return lodash_1.default.isUndefined(value) || lodash_1.default.difference(value, ids).length === 0
        ? true
        : this.createError({ path: this.path, message: `contains conditions that don't exist` });
});
const permissionsAreEquals = (a, b) => a.action === b.action && (a.subject === b.subject || (lodash_1.default.isNil(a.subject) && lodash_1.default.isNil(b.subject)));
exports.permissionsAreEquals = permissionsAreEquals;
const checkNoDuplicatedPermissions = (permissions) => !Array.isArray(permissions) ||
    permissions.every((permA, i) => permissions.slice(i + 1).every((permB) => !(0, exports.permissionsAreEquals)(permA, permB)));
const checkNilFields = (action) => function (fields) {
    // If the parent has no action field, then we ignore this test
    if ((0, fp_1.isNil)(action)) {
        return true;
    }
    return action_1.default.appliesToProperty('fields', action) || (0, fp_1.isNil)(fields);
};
const fieldsPropertyValidation = (action) => utils_1.yup
    .array()
    .of(utils_1.yup.string())
    .nullable()
    .test('field-nested', 'Fields format are incorrect (bad nesting).', common_functions_1.checkFieldsAreCorrectlyNested)
    .test('field-nested', 'Fields format are incorrect (duplicates).', common_functions_1.checkFieldsDontHaveDuplicates)
    .test('fields-restriction', 'The permission at ${path} must have fields set to null or undefined', 
// @ts-expect-error
checkNilFields(action));
exports.permission = utils_1.yup
    .object()
    .shape({
    action: utils_1.yup
        .string()
        .required()
        .test('action-validity', 'action is not an existing permission action', function (actionId) {
        // If the action field is Nil, ignore the test and let the required check handle the error
        if ((0, fp_1.isNil)(actionId)) {
            return true;
        }
        return !!getActionFromProvider(actionId);
    }),
    actionParameters: utils_1.yup.object().nullable(),
    subject: utils_1.yup
        .string()
        .nullable()
        .test('subject-validity', 'Invalid subject submitted', function (subject) {
        // @ts-expect-error
        const action = getActionFromProvider(this.options.parent.action);
        if (!action) {
            return true;
        }
        if ((0, fp_1.isNil)(action.subjects)) {
            return (0, fp_1.isNil)(subject);
        }
        if ((0, fp_1.isArray)(action.subjects)) {
            return action.subjects.includes(subject);
        }
        return false;
    }),
    properties: utils_1.yup
        .object()
        .test('properties-structure', 'Invalid property set at ${path}', function (properties) {
        // @ts-expect-error
        const action = getActionFromProvider(this.options.parent.action);
        const hasNoProperties = (0, fp_1.isEmpty)(properties) || (0, fp_1.isNil)(properties);
        if (!(0, fp_1.has)('options.applyToProperties', action)) {
            return hasNoProperties;
        }
        if (hasNoProperties) {
            return true;
        }
        const { applyToProperties } = action.options;
        if (!(0, fp_1.isArray)(applyToProperties)) {
            return false;
        }
        return Object.keys(properties).every((property) => applyToProperties.includes(property));
    })
        .test('fields-property', 'Invalid fields property at ${path}', async function (properties = {}) {
        // @ts-expect-error
        const action = getActionFromProvider(this.options.parent.action);
        if (!action || !properties) {
            return true;
        }
        if (!action_1.default.appliesToProperty('fields', action)) {
            return true;
        }
        try {
            await fieldsPropertyValidation(action).validate(properties.fields, {
                strict: true,
                abortEarly: false,
            });
            return true;
        }
        catch (e) {
            // Propagate fieldsPropertyValidation error with updated path
            throw this.createError({
                message: e.message,
                path: `${this.path}.fields`,
            });
        }
    }),
    conditions: utils_1.yup.array().of(utils_1.yup.string()),
})
    .noUnknown();
exports.updatePermissions = utils_1.yup
    .object()
    .shape({
    permissions: utils_1.yup
        .array()
        .required()
        .of(exports.permission)
        .test('duplicated-permissions', 'Some permissions are duplicated (same action and subject)', checkNoDuplicatedPermissions),
})
    .required()
    .noUnknown();
exports.default = {
    email: exports.email,
    firstname: exports.firstname,
    lastname: exports.lastname,
    username: exports.username,
    password: exports.password,
    roles: exports.roles,
    isAPluginName,
    arrayOfConditionNames: exports.arrayOfConditionNames,
    permission: exports.permission,
    updatePermissions: exports.updatePermissions,
};
//# sourceMappingURL=common-validators.js.map