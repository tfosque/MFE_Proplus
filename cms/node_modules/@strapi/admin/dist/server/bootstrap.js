"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const utils_2 = require("./utils");
const admin_actions_1 = __importDefault(require("./config/admin-actions"));
const admin_conditions_1 = __importDefault(require("./config/admin-conditions"));
const defaultAdminAuthSettings = {
    providers: {
        autoRegister: false,
        defaultRole: null,
        ssoLockedRoles: null,
    },
};
const registerPermissionActions = async () => {
    await (0, utils_2.getService)('permission').actionProvider.registerMany(admin_actions_1.default.actions);
};
const registerAdminConditions = async () => {
    await (0, utils_2.getService)('permission').conditionProvider.registerMany(admin_conditions_1.default.conditions);
};
const registerModelHooks = () => {
    const { sendDidChangeInterfaceLanguage } = (0, utils_2.getService)('metrics');
    strapi.db.lifecycles.subscribe({
        models: ['admin::user'],
        afterCreate: sendDidChangeInterfaceLanguage,
        afterDelete: sendDidChangeInterfaceLanguage,
        afterUpdate({ params }) {
            if (params.data.preferedLanguage) {
                sendDidChangeInterfaceLanguage();
            }
        },
    });
};
const syncAuthSettings = async () => {
    const adminStore = await strapi.store({ type: 'core', name: 'admin' });
    const adminAuthSettings = await adminStore.get({ key: 'auth' });
    const newAuthSettings = (0, fp_1.merge)(defaultAdminAuthSettings, adminAuthSettings);
    const roleExists = await (0, utils_2.getService)('role').exists({
        id: newAuthSettings.providers.defaultRole,
    });
    // Reset the default SSO role if it has been deleted manually
    if (!roleExists) {
        newAuthSettings.providers.defaultRole = null;
    }
    await adminStore.set({ key: 'auth', value: newAuthSettings });
};
const syncAPITokensPermissions = async () => {
    const validPermissions = strapi.contentAPI.permissions.providers.action.keys();
    const permissionsInDB = await (0, utils_1.pipeAsync)(strapi.query('admin::api-token-permission').findMany, 
    // @ts-expect-error
    (0, fp_1.map)('action'))();
    const unknownPermissions = (0, fp_1.uniq)((0, fp_1.difference)(permissionsInDB, validPermissions));
    if (unknownPermissions.length > 0) {
        await strapi
            .query('admin::api-token-permission')
            .deleteMany({ where: { action: { $in: unknownPermissions } } });
    }
};
exports.default = async ({ strapi }) => {
    await registerAdminConditions();
    await registerPermissionActions();
    registerModelHooks();
    const permissionService = (0, utils_2.getService)('permission');
    const userService = (0, utils_2.getService)('user');
    const roleService = (0, utils_2.getService)('role');
    const apiTokenService = (0, utils_2.getService)('api-token');
    const transferService = (0, utils_2.getService)('transfer');
    const tokenService = (0, utils_2.getService)('token');
    await roleService.createRolesIfNoneExist();
    await roleService.resetSuperAdminPermissions();
    await roleService.displayWarningIfNoSuperAdmin();
    await permissionService.cleanPermissionsInDatabase();
    await userService.displayWarningIfUsersDontHaveRole();
    await syncAuthSettings();
    await syncAPITokensPermissions();
    (0, utils_2.getService)('metrics').startCron(strapi);
    apiTokenService.checkSaltIsDefined();
    transferService.token.checkSaltIsDefined();
    tokenService.checkSecretIsDefined();
};
//# sourceMappingURL=bootstrap.js.map