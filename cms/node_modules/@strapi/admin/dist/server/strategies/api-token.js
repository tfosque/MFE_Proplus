"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.name = exports.verify = exports.authenticate = void 0;
const fp_1 = require("lodash/fp");
const date_fns_1 = require("date-fns");
const utils_1 = require("@strapi/utils");
const constants_1 = __importDefault(require("../services/constants"));
const utils_2 = require("../utils");
const { UnauthorizedError, ForbiddenError } = utils_1.errors;
const isReadScope = (scope) => scope.endsWith('find') || scope.endsWith('findOne');
const extractToken = (ctx) => {
    if (ctx.request && ctx.request.header && ctx.request.header.authorization) {
        const parts = ctx.request.header.authorization.split(/\s+/);
        if (parts[0].toLowerCase() !== 'bearer' || parts.length !== 2) {
            return null;
        }
        return parts[1];
    }
    return null;
};
/**
 * Authenticate the validity of the token
 *
 *  @type {import('.').AuthenticateFunction}
 */
const authenticate = async (ctx) => {
    const apiTokenService = (0, utils_2.getService)('api-token');
    const token = extractToken(ctx);
    if (!token) {
        return { authenticated: false };
    }
    // @ts-ignore
    const apiToken = await apiTokenService.getBy({
        accessKey: apiTokenService.hash(token),
    });
    // token not found
    if (!apiToken) {
        return { authenticated: false };
    }
    const currentDate = new Date();
    if (!(0, fp_1.isNil)(apiToken.expiresAt)) {
        const expirationDate = new Date(apiToken.expiresAt);
        // token has expired
        if (expirationDate < currentDate) {
            return { authenticated: false, error: new UnauthorizedError('Token expired') };
        }
    }
    // update lastUsedAt if the token has not been used in the last hour
    // @ts-ignore
    const hoursSinceLastUsed = (0, date_fns_1.differenceInHours)(currentDate, (0, date_fns_1.parseISO)(apiToken.lastUsedAt));
    if (hoursSinceLastUsed >= 1) {
        await strapi.query('admin::api-token').update({
            where: { id: apiToken.id },
            data: { lastUsedAt: currentDate },
        });
    }
    if (apiToken.type === constants_1.default.API_TOKEN_TYPE.CUSTOM) {
        const ability = await strapi.contentAPI.permissions.engine.generateAbility(apiToken.permissions.map((action) => ({ action })));
        return { authenticated: true, ability, credentials: apiToken };
    }
    return { authenticated: true, credentials: apiToken };
};
exports.authenticate = authenticate;
/**
 * Verify the token has the required abilities for the requested scope
 *
 *  @type {import('.').VerifyFunction}
 */
const verify = (auth, config) => {
    const { credentials: apiToken, ability } = auth;
    if (!apiToken) {
        throw new UnauthorizedError('Token not found');
    }
    const currentDate = new Date();
    if (!(0, fp_1.isNil)(apiToken.expiresAt)) {
        const expirationDate = new Date(apiToken.expiresAt);
        // token has expired
        if (expirationDate < currentDate) {
            throw new UnauthorizedError('Token expired');
        }
    }
    // Full access
    if (apiToken.type === constants_1.default.API_TOKEN_TYPE.FULL_ACCESS) {
        return;
    }
    // Read only
    if (apiToken.type === constants_1.default.API_TOKEN_TYPE.READ_ONLY) {
        /**
         * If you don't have `full-access` you can only access `find` and `findOne`
         * scopes. If the route has no scope, then you can't get access to it.
         */
        const scopes = (0, fp_1.castArray)(config.scope);
        if (config.scope && scopes.every(isReadScope)) {
            return;
        }
    }
    // Custom
    else if (apiToken.type === constants_1.default.API_TOKEN_TYPE.CUSTOM) {
        if (!ability) {
            throw new ForbiddenError();
        }
        const scopes = (0, fp_1.castArray)(config.scope);
        const isAllowed = scopes.every((scope) => ability.can(scope));
        if (isAllowed) {
            return;
        }
    }
    throw new ForbiddenError();
};
exports.verify = verify;
exports.name = 'api-token';
/** @type {import('.').AuthStrategy} */
exports.default = {
    name: 'api-token',
    authenticate: exports.authenticate,
    verify: exports.verify,
};
//# sourceMappingURL=api-token.js.map