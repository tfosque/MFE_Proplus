"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.name = exports.verify = exports.authenticate = void 0;
const date_fns_1 = require("date-fns");
const utils_1 = require("@strapi/utils");
const fp_1 = require("lodash/fp");
const utils_2 = require("../utils");
const { UnauthorizedError, ForbiddenError } = utils_1.errors;
const extractToken = (ctx) => {
    if (ctx.request && ctx.request.header && ctx.request.header.authorization) {
        const parts = ctx.request.header.authorization.split(/\s+/);
        if (parts[0].toLowerCase() !== 'bearer' || parts.length !== 2) {
            return null;
        }
        return parts[1];
    }
    return null;
};
/**
 * Authenticate the validity of the token
 *
 *  @type {import('.').AuthenticateFunction}
 */
const authenticate = async (ctx) => {
    const { token: tokenService } = (0, utils_2.getService)('transfer');
    const token = extractToken(ctx);
    if (!token) {
        return { authenticated: false };
    }
    // @ts-ignore
    const transferToken = await tokenService.getBy({ accessKey: tokenService.hash(token) });
    // Check if the token exists
    if (!transferToken) {
        return { authenticated: false };
    }
    // Check if the token has expired
    const currentDate = new Date();
    if (!(0, fp_1.isNil)(transferToken.expiresAt)) {
        const expirationDate = new Date(transferToken.expiresAt);
        if (expirationDate < currentDate) {
            return { authenticated: false, error: new UnauthorizedError('Token expired') };
        }
    }
    // Update token metadata if the token has not been used in the last hour
    // @ts-ignore
    const hoursSinceLastUsed = (0, date_fns_1.differenceInHours)(currentDate, (0, date_fns_1.parseISO)(transferToken.lastUsedAt));
    if (hoursSinceLastUsed >= 1) {
        await strapi.query('admin::api-token').update({
            where: { id: transferToken.id },
            data: { lastUsedAt: currentDate },
        });
    }
    // Generate an ability based on the token permissions
    const ability = await (0, utils_2.getService)('transfer').permission.engine.generateAbility(transferToken.permissions.map((action) => ({ action })));
    return { authenticated: true, ability, credentials: transferToken };
};
exports.authenticate = authenticate;
/**
 * Verify the token has the required abilities for the requested scope
 *
 *  @type {import('.').VerifyFunction}
 */
const verify = async (auth, config = {}) => {
    const { credentials: transferToken, ability } = auth;
    if (!transferToken) {
        throw new UnauthorizedError('Token not found');
    }
    const currentDate = new Date();
    if (!(0, fp_1.isNil)(transferToken.expiresAt)) {
        const expirationDate = new Date(transferToken.expiresAt);
        // token has expired
        if (expirationDate < currentDate) {
            throw new UnauthorizedError('Token expired');
        }
    }
    if (!ability) {
        throw new ForbiddenError();
    }
    // @ts-expect-error
    const scopes = (0, fp_1.castArray)(config.scope ?? []);
    const isAllowed = scopes.every((scope) => ability.can(scope));
    if (!isAllowed) {
        throw new ForbiddenError();
    }
};
exports.verify = verify;
exports.name = 'data-transfer';
/** @type {import('.').AuthStrategy} */
exports.default = {
    name: exports.name,
    authenticate: exports.authenticate,
    verify: exports.verify,
};
//# sourceMappingURL=data-transfer.js.map