"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkSaltIsDefined = exports.hash = exports.regenerate = exports.revoke = exports.update = exports.getByName = exports.getById = exports.getBy = exports.exists = exports.list = exports.create = exports.hasAccessKey = void 0;
const crypto_1 = __importDefault(require("crypto"));
const assert_1 = __importDefault(require("assert"));
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const constants_1 = __importDefault(require("../constants"));
const utils_2 = require("../../utils");
const { ValidationError, NotFoundError } = utils_1.errors;
const TRANSFER_TOKEN_UID = 'admin::transfer-token';
const TRANSFER_TOKEN_PERMISSION_UID = 'admin::transfer-token-permission';
const SELECT_FIELDS = [
    'id',
    'name',
    'description',
    'lastUsedAt',
    'lifespan',
    'expiresAt',
    'createdAt',
    'updatedAt',
];
const POPULATE_FIELDS = ['permissions'];
/**
 * Return a list of all tokens and their permissions
 */
const list = async () => {
    const tokens = await strapi.query(TRANSFER_TOKEN_UID).findMany({
        select: SELECT_FIELDS,
        populate: POPULATE_FIELDS,
        orderBy: { name: 'ASC' },
    });
    if (!tokens)
        return tokens;
    return tokens.map((token) => flattenTokenPermissions(token));
};
exports.list = list;
/**
 * Create a random token's access key
 */
const generateRandomAccessKey = () => crypto_1.default.randomBytes(128).toString('hex');
/**
 * Validate the given access key's format and returns it if valid
 */
const validateAccessKey = (accessKey) => {
    (0, assert_1.default)(typeof accessKey === 'string', 'Access key needs to be a string');
    (0, assert_1.default)(accessKey.length >= 15, 'Access key needs to have at least 15 characters');
    return accessKey;
};
const hasAccessKey = (attributes) => {
    return 'accessKey' in attributes;
};
exports.hasAccessKey = hasAccessKey;
/**
 * Create a token and its permissions
 */
const create = async (attributes) => {
    const accessKey = (0, exports.hasAccessKey)(attributes)
        ? validateAccessKey(attributes.accessKey)
        : generateRandomAccessKey();
    // Make sure the access key isn't picked up directly from the attributes for the next steps
    delete attributes.accessKey;
    assertTokenPermissionsValidity(attributes);
    assertValidLifespan(attributes);
    const result = (await strapi.db.transaction(async () => {
        const transferToken = await strapi.query(TRANSFER_TOKEN_UID).create({
            select: SELECT_FIELDS,
            populate: POPULATE_FIELDS,
            data: {
                ...(0, fp_1.omit)('permissions', attributes),
                accessKey: hash(accessKey),
                ...getExpirationFields(attributes.lifespan),
            },
        });
        await Promise.all((0, fp_1.uniq)(attributes.permissions).map((action) => strapi
            .query(TRANSFER_TOKEN_PERMISSION_UID)
            .create({ data: { action, token: transferToken } })));
        const currentPermissions = await strapi.entityService.load(TRANSFER_TOKEN_UID, transferToken, 'permissions');
        if (currentPermissions) {
            Object.assign(transferToken, { permissions: (0, fp_1.map)('action', currentPermissions) });
        }
        return transferToken;
    }));
    return { ...result, accessKey };
};
exports.create = create;
/**
 * Update a token and its permissions
 */
const update = async (id, attributes) => {
    // retrieve token without permissions
    const originalToken = await strapi.query(TRANSFER_TOKEN_UID).findOne({ where: { id } });
    if (!originalToken) {
        throw new NotFoundError('Token not found');
    }
    assertTokenPermissionsValidity(attributes);
    assertValidLifespan(attributes);
    return strapi.db.transaction(async () => {
        const updatedToken = await strapi.query(TRANSFER_TOKEN_UID).update({
            select: SELECT_FIELDS,
            where: { id },
            data: {
                ...(0, fp_1.omit)('permissions', attributes),
            },
        });
        if (attributes.permissions) {
            const currentPermissionsResult = await strapi.entityService.load(TRANSFER_TOKEN_UID, updatedToken, 'permissions');
            const currentPermissions = (0, fp_1.map)('action', currentPermissionsResult || []);
            const newPermissions = (0, fp_1.uniq)(attributes.permissions);
            const actionsToDelete = (0, fp_1.difference)(currentPermissions, newPermissions);
            const actionsToAdd = (0, fp_1.difference)(newPermissions, currentPermissions);
            // TODO: improve efficiency here
            // method using a loop -- works but very inefficient
            await Promise.all(actionsToDelete.map((action) => strapi.query(TRANSFER_TOKEN_PERMISSION_UID).delete({
                where: { action, token: id },
            })));
            // TODO: improve efficiency here
            // using a loop -- works but very inefficient
            await Promise.all(actionsToAdd.map((action) => strapi.query(TRANSFER_TOKEN_PERMISSION_UID).create({
                data: { action, token: id },
            })));
        }
        // retrieve permissions
        const permissionsFromDb = (await strapi.entityService.load(TRANSFER_TOKEN_UID, updatedToken, 'permissions'));
        return {
            ...updatedToken,
            permissions: permissionsFromDb ? permissionsFromDb.map((p) => p.action) : undefined,
        };
    });
};
exports.update = update;
/**
 * Revoke (delete) a token
 */
const revoke = async (id) => {
    return strapi.db.transaction(async () => strapi
        .query(TRANSFER_TOKEN_UID)
        .delete({ select: SELECT_FIELDS, populate: POPULATE_FIELDS, where: { id } }));
};
exports.revoke = revoke;
/**
 *  Get a token
 */
const getBy = async (whereParams = {}) => {
    if (Object.keys(whereParams).length === 0) {
        return null;
    }
    const token = await strapi
        .query(TRANSFER_TOKEN_UID)
        .findOne({ select: SELECT_FIELDS, populate: POPULATE_FIELDS, where: whereParams });
    if (!token)
        return token;
    return flattenTokenPermissions(token);
};
exports.getBy = getBy;
/**
 * Retrieve a token by id
 */
const getById = async (id) => {
    return getBy({ id });
};
exports.getById = getById;
/**
 * Retrieve a token by name
 */
const getByName = async (name) => {
    return getBy({ name });
};
exports.getByName = getByName;
/**
 * Check if token exists
 */
const exists = async (whereParams = {}) => {
    const transferToken = await getBy(whereParams);
    return !!transferToken;
};
exports.exists = exists;
const regenerate = async (id) => {
    const accessKey = crypto_1.default.randomBytes(128).toString('hex');
    const transferToken = (await strapi.db.transaction(async () => strapi.query(TRANSFER_TOKEN_UID).update({
        select: ['id', 'accessKey'],
        where: { id },
        data: {
            accessKey: hash(accessKey),
        },
    })));
    if (!transferToken) {
        throw new NotFoundError('The provided token id does not exist');
    }
    return {
        ...transferToken,
        accessKey,
    };
};
exports.regenerate = regenerate;
const getExpirationFields = (lifespan) => {
    // it must be nil or a finite number >= 0
    const isValidNumber = Number.isFinite(lifespan) && lifespan > 0;
    if (!isValidNumber && !(0, fp_1.isNil)(lifespan)) {
        throw new ValidationError('lifespan must be a positive number or null');
    }
    return {
        lifespan: lifespan || null,
        expiresAt: lifespan ? Date.now() + lifespan : null,
    };
};
/**
 * Return a secure sha512 hash of an accessKey
 */
const hash = (accessKey) => {
    const { hasValidTokenSalt } = (0, utils_2.getService)('transfer').utils;
    if (!hasValidTokenSalt()) {
        throw new TypeError('Required token salt is not defined');
    }
    return crypto_1.default
        .createHmac('sha512', strapi.config.get('admin.transfer.token.salt'))
        .update(accessKey)
        .digest('hex');
};
exports.hash = hash;
const checkSaltIsDefined = () => {
    const { hasValidTokenSalt, isDisabledFromEnv } = (0, utils_2.getService)('transfer').utils;
    // Ignore the check if the data-transfer feature is manually disabled
    if (isDisabledFromEnv()) {
        return;
    }
    if (!hasValidTokenSalt()) {
        process.emitWarning(`Missing transfer.token.salt: Data transfer features have been disabled.
Please set transfer.token.salt in config/admin.js (ex: you can generate one using Node with \`crypto.randomBytes(16).toString('base64')\`)
For security reasons, prefer storing the secret in an environment variable and read it in config/admin.js. See https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/configurations/optional/environment.html#configuration-using-environment-variables.`);
    }
};
exports.checkSaltIsDefined = checkSaltIsDefined;
/**
 * Flatten a token's database permissions objects to an array of strings
 */
const flattenTokenPermissions = (token) => {
    if (!token)
        return token;
    return {
        ...token,
        permissions: (0, fp_1.isArray)(token.permissions)
            ? (0, fp_1.map)('action', token.permissions)
            : token.permissions,
    };
};
/**
 * Assert that a token's permissions are valid
 */
const assertTokenPermissionsValidity = (attributes) => {
    const permissionService = strapi.admin.services.transfer.permission;
    const validPermissions = permissionService.providers.action.keys();
    const invalidPermissions = (0, fp_1.difference)(attributes.permissions, validPermissions);
    if (!(0, fp_1.isEmpty)(invalidPermissions)) {
        throw new ValidationError(`Unknown permissions provided: ${invalidPermissions.join(', ')}`);
    }
};
/**
 * Assert that a token's lifespan is valid
 */
const assertValidLifespan = ({ lifespan }) => {
    if ((0, fp_1.isNil)(lifespan)) {
        return;
    }
    if (!Object.values(constants_1.default.TRANSFER_TOKEN_LIFESPANS).includes(lifespan)) {
        throw new ValidationError(`lifespan must be one of the following values: 
      ${Object.values(constants_1.default.TRANSFER_TOKEN_LIFESPANS).join(', ')}`);
    }
};
//# sourceMappingURL=token.js.map