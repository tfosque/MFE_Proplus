"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constants = exports.checkRolesIdForDeletion = exports.resetSuperAdminPermissions = exports.assignPermissions = exports.hasSuperAdminRole = exports.addPermissions = exports.displayWarningIfNoSuperAdmin = exports.createRolesIfNoneExist = exports.getSuperAdminWithUsersCount = exports.getSuperAdmin = exports.getUsersCount = exports.deleteByIds = exports.count = exports.exists = exports.update = exports.findAllWithUsersCount = exports.find = exports.findOneWithUsersCount = exports.findOne = exports.create = exports.sanitizeRole = exports.hooks = void 0;
/* eslint-disable @typescript-eslint/default-param-last */
const lodash_1 = __importDefault(require("lodash"));
const fp_1 = require("lodash/fp");
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const utils_1 = require("@strapi/utils");
const permission_1 = __importDefault(require("../domain/permission"));
const permission_2 = require("../validation/permission");
const utils_2 = require("../utils");
const constants_1 = require("./constants");
const { createAsyncSeriesWaterfallHook } = utils_1.hooks;
const { ApplicationError } = utils_1.errors;
const hooks = {
    willResetSuperAdminPermissions: createAsyncSeriesWaterfallHook(),
};
exports.hooks = hooks;
const ACTIONS = {
    publish: 'plugin::content-manager.explorer.publish',
};
const sanitizeRole = (0, fp_1.omit)(['users', 'permissions']);
exports.sanitizeRole = sanitizeRole;
const COMPARABLE_FIELDS = ['conditions', 'properties', 'subject', 'action', 'actionParameters'];
const pickComparableFields = (0, fp_1.pick)(COMPARABLE_FIELDS);
const jsonClean = (data) => JSON.parse(JSON.stringify(data));
/**
 * Compare two permissions
 * @param {Permission} p1
 * @param {Permission} p2
 * @returns {boolean}
 */
const arePermissionsEqual = (p1, p2) => {
    if (p1.action === p2.action) {
        return (0, fast_deep_equal_1.default)(jsonClean(pickComparableFields(p1)), jsonClean(pickComparableFields(p2)));
    }
    return false;
};
/**
 * Create and save a role in database
 * @param attributes A partial role object
 * @returns {Promise<role>}
 */
const create = async (attributes) => {
    const alreadyExists = await exists({ name: attributes.name });
    if (alreadyExists) {
        throw new ApplicationError(`The name must be unique and a role with name \`${attributes.name}\` already exists.`);
    }
    // @ts-expect-error
    const autoGeneratedCode = `${lodash_1.default.kebabCase(attributes.name)}-${(0, utils_1.generateTimestampCode)()}`;
    const rolesWithCode = {
        ...attributes,
        code: attributes.code || autoGeneratedCode,
    };
    const result = await strapi.query('admin::role').create({ data: rolesWithCode });
    strapi.eventHub.emit('role.create', { role: sanitizeRole(result) });
    return result;
};
exports.create = create;
/**
 * Find a role in database
 * @param params query params to find the role
 * @param populate
 * @returns {Promise<role>}
 */
const findOne = (params = {}, populate) => {
    return strapi.query('admin::role').findOne({ where: params, populate });
};
exports.findOne = findOne;
/**
 * Find a role in database with usersCounts
 * @param params query params to find the role
 * @param populate
 * @returns {Promise<role>}
 */
const findOneWithUsersCount = async (params = {}, populate) => {
    const role = await strapi.query('admin::role').findOne({ where: params, populate });
    if (role) {
        role.usersCount = await getUsersCount(role.id);
    }
    return role;
};
exports.findOneWithUsersCount = findOneWithUsersCount;
/**
 * Find roles in database
 * @param params query params to find the roles
 * @param populate
 * @returns {Promise<array>}
 */
const find = (params = {}, populate) => {
    return strapi.query('admin::role').findMany({ where: params, populate });
};
exports.find = find;
/**
 * Find all roles in database
 * @returns {Promise<array>}
 */
const findAllWithUsersCount = async (params) => {
    const roles = (await strapi.entityService.findMany('admin::role', params));
    for (const role of roles) {
        role.usersCount = await getUsersCount(role.id);
    }
    return roles;
};
exports.findAllWithUsersCount = findAllWithUsersCount;
/**
 * Update a role in database
 * @param params query params to find the role to update
 * @param attributes A partial role object
 * @returns {Promise<role>}
 */
const update = async (params, attributes) => {
    const sanitizedAttributes = lodash_1.default.omit(attributes, ['code']);
    if (lodash_1.default.has(params, 'id') && lodash_1.default.has(sanitizedAttributes, 'name')) {
        const alreadyExists = await exists({
            name: sanitizedAttributes.name,
            id: { $ne: params.id },
        });
        if (alreadyExists) {
            throw new ApplicationError(`The name must be unique and a role with name \`${sanitizedAttributes.name}\` already exists.`);
        }
    }
    const result = await strapi
        .query('admin::role')
        .update({ where: params, data: sanitizedAttributes });
    strapi.eventHub.emit('role.update', { role: sanitizeRole(result) });
    return result;
};
exports.update = update;
/**
 * Check if a role exists in database
 * @param params query params to find the role
 * @returns {Promise<boolean>}
 */
const exists = async (params = {}) => {
    const count = await strapi.query('admin::role').count({ where: params });
    return count > 0;
};
exports.exists = exists;
/**
 * Count the number of roles based on search params
 * @param params params used for the query
 * @returns {Promise<number>}
 */
const count = async (params = {}) => {
    return strapi.query('admin::role').count(params);
};
exports.count = count;
/**
 * Check if the given roles id can be deleted safely, throw otherwise
 * @param ids
 * @returns {Promise<void>}
 */
const checkRolesIdForDeletion = async (ids = []) => {
    const superAdminRole = await getSuperAdmin();
    if (superAdminRole && (0, utils_1.stringIncludes)(ids, superAdminRole.id)) {
        throw new ApplicationError('You cannot delete the super admin role');
    }
    for (const roleId of ids) {
        const usersCount = await getUsersCount(roleId);
        if (usersCount !== 0) {
            throw new ApplicationError('Some roles are still assigned to some users');
        }
    }
};
exports.checkRolesIdForDeletion = checkRolesIdForDeletion;
/**
 * Delete roles in database if they have no user assigned
 * @param ids query params to find the roles
 * @returns {Promise<array>}
 */
const deleteByIds = async (ids = []) => {
    await checkRolesIdForDeletion(ids);
    await (0, utils_2.getService)('permission').deleteByRolesIds(ids);
    const deletedRoles = [];
    for (const id of ids) {
        const deletedRole = await strapi.query('admin::role').delete({ where: { id } });
        if (deletedRole) {
            strapi.eventHub.emit('role.delete', { role: deletedRole });
            deletedRoles.push(deletedRole);
        }
    }
    return deletedRoles;
};
exports.deleteByIds = deleteByIds;
/** Count the number of users for some roles
 * @returns {Promise<number>}
 * @param roleId
 */
const getUsersCount = async (roleId) => {
    return strapi.query('admin::user').count({ where: { roles: { id: roleId } } });
};
exports.getUsersCount = getUsersCount;
/** Returns admin role
 * @returns {Promise<role>}
 */
const getSuperAdmin = () => findOne({ code: constants_1.SUPER_ADMIN_CODE });
exports.getSuperAdmin = getSuperAdmin;
/** Returns admin role with userCount
 * @returns {Promise<role>}
 */
const getSuperAdminWithUsersCount = () => findOneWithUsersCount({ code: constants_1.SUPER_ADMIN_CODE });
exports.getSuperAdminWithUsersCount = getSuperAdminWithUsersCount;
/** Create superAdmin, Author and Editor role is no role already exist
 * @returns {Promise<>}
 */
const createRolesIfNoneExist = async () => {
    const someRolesExist = await exists();
    if (someRolesExist) {
        return;
    }
    const { actionProvider } = (0, utils_2.getService)('permission');
    const allActions = actionProvider.values();
    const contentTypesActions = allActions.filter((a) => a.section === 'contentTypes');
    // create 3 roles
    const superAdminRole = await create({
        name: 'Super Admin',
        code: 'strapi-super-admin',
        description: 'Super Admins can access and manage all features and settings.',
    });
    await (0, utils_2.getService)('user').assignARoleToAll(superAdminRole.id);
    const editorRole = await create({
        name: 'Editor',
        code: 'strapi-editor',
        description: 'Editors can manage and publish contents including those of other users.',
    });
    const authorRole = await create({
        name: 'Author',
        code: 'strapi-author',
        description: 'Authors can manage the content they have created.',
    });
    // create content-type permissions for each role
    const editorPermissions = (0, utils_2.getService)('content-type').getPermissionsWithNestedFields(contentTypesActions, {
        restrictedSubjects: ['plugin::users-permissions.user'],
    });
    const authorPermissions = editorPermissions
        .filter(({ action }) => action !== ACTIONS.publish)
        .map((permission) => permission_1.default.create({ ...permission, conditions: ['admin::is-creator'] }));
    editorPermissions.push(...getDefaultPluginPermissions());
    authorPermissions.push(...getDefaultPluginPermissions({ isAuthor: true }));
    // assign permissions to roles
    await addPermissions(editorRole.id, editorPermissions);
    await addPermissions(authorRole.id, authorPermissions);
};
exports.createRolesIfNoneExist = createRolesIfNoneExist;
const getDefaultPluginPermissions = ({ isAuthor = false } = {}) => {
    const conditions = isAuthor ? ['admin::is-creator'] : [];
    // add plugin permissions for each role
    return [
        { action: 'plugin::upload.read', conditions },
        { action: 'plugin::upload.configure-view' },
        { action: 'plugin::upload.assets.create' },
        { action: 'plugin::upload.assets.update', conditions },
        { action: 'plugin::upload.assets.download' },
        { action: 'plugin::upload.assets.copy-link' },
    ].map(permission_1.default.create);
};
/** Display a warning if the role superAdmin doesn't exist
 *  or if the role is not assigned to at least one user
 * @returns {Promise<>}
 */
const displayWarningIfNoSuperAdmin = async () => {
    const superAdminRole = await getSuperAdminWithUsersCount();
    const someUsersExists = await (0, utils_2.getService)('user').exists();
    if (!superAdminRole) {
        strapi.log.warn("Your application doesn't have a super admin role.");
    }
    else if (someUsersExists && superAdminRole.usersCount === 0) {
        strapi.log.warn("Your application doesn't have a super admin user.");
    }
};
exports.displayWarningIfNoSuperAdmin = displayWarningIfNoSuperAdmin;
/**
 * Assign permissions to a role
 * @param {string|int} roleId - role ID
 * @param {Array<Permission{action,subject,fields,conditions}>} permissions - permissions to assign to the role
 */
const assignPermissions = async (roleId, permissions = []) => {
    await (0, permission_2.validatePermissionsExist)(permissions);
    // Internal actions are not handled by the role service, so any permission
    // with an internal action is filtered out
    const internalActions = (0, utils_2.getService)('permission')
        .actionProvider.values()
        .filter((action) => action.section === 'internal')
        .map((action) => action.actionId);
    const superAdmin = (await (0, utils_2.getService)('role').getSuperAdmin());
    const isSuperAdmin = superAdmin && superAdmin.id === roleId;
    const assignRole = (0, fp_1.set)('role', roleId);
    const permissionsWithRole = permissions
        // Add the role attribute to every permission
        .map(assignRole)
        // Transform each permission into a Permission instance
        // @ts-expect-error
        .map(permission_1.default.create);
    const existingPermissions = (await (0, utils_2.getService)('permission').findMany({
        where: { role: { id: roleId } },
        populate: ['role'],
    }));
    const permissionsToAdd = (0, fp_1.differenceWith)(arePermissionsEqual, permissionsWithRole, existingPermissions).filter((permission) => !internalActions.includes(permission.action));
    const permissionsToDelete = (0, fp_1.differenceWith)(arePermissionsEqual, existingPermissions, permissionsWithRole
    // @ts-expect-error
    ).filter((permission) => !internalActions.includes(permission.action));
    const permissionsToReturn = (0, fp_1.differenceBy)('id', permissionsToDelete, existingPermissions);
    if (permissionsToDelete.length > 0) {
        await (0, utils_2.getService)('permission').deleteByIds(permissionsToDelete.map((0, fp_1.prop)('id')));
    }
    if (permissionsToAdd.length > 0) {
        const newPermissions = (await addPermissions(roleId, permissionsToAdd));
        permissionsToReturn.push(...newPermissions);
    }
    if (!isSuperAdmin && (permissionsToAdd.length || permissionsToDelete.length)) {
        await (0, utils_2.getService)('metrics').sendDidUpdateRolePermissions();
    }
    return permissionsToReturn;
};
exports.assignPermissions = assignPermissions;
const addPermissions = async (roleId, permissions) => {
    const { conditionProvider, createMany } = (0, utils_2.getService)('permission');
    const { sanitizeConditions } = permission_1.default;
    const permissionsWithRole = permissions
        .map((0, fp_1.set)('role', roleId))
        // @ts-expect-error
        .map(sanitizeConditions(conditionProvider))
        .map(permission_1.default.create);
    return createMany(permissionsWithRole);
};
exports.addPermissions = addPermissions;
const isContentTypeAction = (action) => action.section === constants_1.CONTENT_TYPE_SECTION;
/**
 * Reset super admin permissions (giving it all permissions)
 * @returns {Promise<>}
 */
const resetSuperAdminPermissions = async () => {
    // @ts-ignore
    const superAdminRole = await (0, utils_2.getService)('role').getSuperAdmin();
    if (!superAdminRole) {
        return;
    }
    const permissionService = (0, utils_2.getService)('permission');
    const contentTypeService = (0, utils_2.getService)('content-type');
    const allActions = permissionService.actionProvider.values();
    const contentTypesActions = allActions.filter((action) => isContentTypeAction(action));
    const otherActions = allActions.filter((action) => !isContentTypeAction(action));
    // First, get the content-types permissions
    const permissions = contentTypeService.getPermissionsWithNestedFields(contentTypesActions);
    // Then add every other permission
    const otherPermissions = otherActions.reduce((acc, action) => {
        const { actionId, subjects } = action;
        if ((0, fp_1.isArray)(subjects)) {
            acc.push(
            // @ts-expect-error
            ...subjects.map((subject) => permission_1.default.create({ action: actionId, subject })));
        }
        else {
            // @ts-expect-error
            acc.push(permission_1.default.create({ action: actionId }));
        }
        return acc;
    }, []);
    permissions.push(...otherPermissions);
    const transformedPermissions = (await hooks.willResetSuperAdminPermissions.call(permissions));
    await assignPermissions(superAdminRole.id, transformedPermissions);
};
exports.resetSuperAdminPermissions = resetSuperAdminPermissions;
/**
 * Check if a user object includes the super admin role
 * @param {object} user
 * @return {boolean}
 */
const hasSuperAdminRole = (user) => {
    const roles = lodash_1.default.get(user, 'roles', []);
    return roles.map((0, fp_1.prop)('code')).includes(constants_1.SUPER_ADMIN_CODE);
};
exports.hasSuperAdminRole = hasSuperAdminRole;
const constants = {
    superAdminCode: constants_1.SUPER_ADMIN_CODE,
};
exports.constants = constants;
//# sourceMappingURL=role.js.map