"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLanguagesInUse = exports.resetPasswordByEmail = exports.displayWarningIfUsersDontHaveRole = exports.assignARoleToAll = exports.count = exports.countUsersWithoutRole = exports.deleteByIds = exports.deleteById = exports.findPage = exports.findOneByEmail = exports.findOne = exports.sanitizeUser = exports.register = exports.findRegistrationInfo = exports.exists = exports.updateById = exports.create = void 0;
const lodash_1 = __importDefault(require("lodash"));
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const user_1 = require("../domain/user");
const common_validators_1 = require("../validation/common-validators");
const utils_2 = require("../utils");
const constants_1 = require("./constants");
const { ValidationError } = utils_1.errors;
const sanitizeUserRoles = (role) => lodash_1.default.pick(role, ['id', 'name', 'description', 'code']);
/**
 * Remove private user fields
 * @param {Object} user - user to sanitize
 */
const sanitizeUser = (user) => {
    return {
        ...lodash_1.default.omit(user, ['password', 'resetPasswordToken', 'registrationToken', 'roles']),
        roles: user.roles && user.roles.map(sanitizeUserRoles),
    };
};
exports.sanitizeUser = sanitizeUser;
/**
 * Create and save a user in database
 * @param attributes A partial user object
 * @returns {Promise<user>}
 */
const create = async (attributes) => {
    const userInfo = {
        registrationToken: (0, utils_2.getService)('token').createToken(),
        ...attributes,
    };
    if (lodash_1.default.has(attributes, 'password')) {
        userInfo.password = await (0, utils_2.getService)('auth').hashPassword(attributes.password);
    }
    const user = (0, user_1.createUser)(userInfo);
    const createdUser = await strapi.query('admin::user').create({ data: user, populate: ['roles'] });
    (0, utils_2.getService)('metrics').sendDidInviteUser();
    strapi.eventHub.emit('user.create', { user: sanitizeUser(createdUser) });
    return createdUser;
};
exports.create = create;
/**
 * Update a user in database
 * @param id query params to find the user to update
 * @param attributes A partial user object
 * @returns {Promise<user>}
 */
const updateById = async (id, attributes) => {
    // Check at least one super admin remains
    if (lodash_1.default.has(attributes, 'roles')) {
        const lastAdminUser = await isLastSuperAdminUser(id);
        const superAdminRole = await (0, utils_2.getService)('role').getSuperAdminWithUsersCount();
        const willRemoveSuperAdminRole = !(0, utils_1.stringIncludes)(attributes.roles, superAdminRole.id);
        if (lastAdminUser && willRemoveSuperAdminRole) {
            throw new ValidationError('You must have at least one user with super admin role.');
        }
    }
    // cannot disable last super admin
    if (attributes.isActive === false) {
        const lastAdminUser = await isLastSuperAdminUser(id);
        if (lastAdminUser) {
            throw new ValidationError('You must have at least one user with super admin role.');
        }
    }
    // hash password if a new one is sent
    if (lodash_1.default.has(attributes, 'password')) {
        const hashedPassword = await (0, utils_2.getService)('auth').hashPassword(attributes.password);
        const updatedUser = await strapi.query('admin::user').update({
            where: { id },
            data: {
                ...attributes,
                password: hashedPassword,
            },
            populate: ['roles'],
        });
        strapi.eventHub.emit('user.update', { user: sanitizeUser(updatedUser) });
        return updatedUser;
    }
    const updatedUser = await strapi.query('admin::user').update({
        where: { id },
        data: attributes,
        populate: ['roles'],
    });
    if (updatedUser) {
        strapi.eventHub.emit('user.update', { user: sanitizeUser(updatedUser) });
    }
    return updatedUser;
};
exports.updateById = updateById;
/**
 * Reset a user password by email. (Used in admin:reset CLI)
 * @param {string} email - user email
 * @param {string} password - new password
 */
const resetPasswordByEmail = async (email, password) => {
    const user = await strapi.query('admin::user').findOne({ where: { email }, populate: ['roles'] });
    if (!user) {
        throw new Error(`User not found for email: ${email}`);
    }
    try {
        await common_validators_1.password.validate(password);
    }
    catch (error) {
        throw new ValidationError('Invalid password. Expected a minimum of 8 characters with at least one number and one uppercase letter');
    }
    await updateById(user.id, { password });
};
exports.resetPasswordByEmail = resetPasswordByEmail;
/**
 * Check if a user is the last super admin
 * @param {int|string} userId user's id to look for
 */
const isLastSuperAdminUser = async (userId) => {
    const user = await findOne(userId);
    const superAdminRole = await (0, utils_2.getService)('role').getSuperAdminWithUsersCount();
    // @ts-expect-error
    return superAdminRole.usersCount === 1 && (0, user_1.hasSuperAdminRole)(user);
};
/**
 * Check if a user with specific attributes exists in the database
 * @param attributes A partial user object
 * @returns {Promise<boolean>}
 */
const exists = async (attributes = {}) => {
    return (await strapi.query('admin::user').count({ where: attributes })) > 0;
};
exports.exists = exists;
/**
 * Returns a user registration info
 * @param {string} registrationToken - a user registration token
 * @returns {Promise<registrationInfo>} - Returns user email, firstname and lastname
 */
const findRegistrationInfo = async (registrationToken) => {
    const user = await strapi.query('admin::user').findOne({ where: { registrationToken } });
    if (!user) {
        return undefined;
    }
    return lodash_1.default.pick(user, ['email', 'firstname', 'lastname']);
};
exports.findRegistrationInfo = findRegistrationInfo;
/**
 * Registers a user based on a registrationToken and some informations to update
 * @param {Object} params
 * @param {Object} params.registrationToken registration token
 * @param {Object} params.userInfo user info
 */
const register = async ({ registrationToken, userInfo }) => {
    const matchingUser = await strapi.query('admin::user').findOne({ where: { registrationToken } });
    if (!matchingUser) {
        throw new ValidationError('Invalid registration info');
    }
    return (0, utils_2.getService)('user').updateById(matchingUser.id, {
        password: userInfo.password,
        firstname: userInfo.firstname,
        lastname: userInfo.lastname,
        registrationToken: null,
        isActive: true,
    });
};
exports.register = register;
/**
 * Find one user
 */
const findOne = async (id, populate = ['roles']) => {
    return strapi.entityService.findOne('admin::user', id, { populate });
};
exports.findOne = findOne;
/**
 * Find one user by its email
 * @param {string} id  email
 * @param {string || string[] || object} populate
 * @returns
 */
const findOneByEmail = async (email, populate = []) => {
    return strapi.query('admin::user').findOne({
        where: { email },
        populate,
    });
};
exports.findOneByEmail = findOneByEmail;
/** Find many users (paginated)
 * @param query
 * @returns {Promise<user>}
 */
const findPage = async (query = {}) => {
    const enrichedQuery = (0, fp_1.defaults)({ populate: ['roles'] }, query);
    return strapi.entityService.findPage('admin::user', enrichedQuery);
};
exports.findPage = findPage;
/** Delete a user
 * @param id id of the user to delete
 * @returns {Promise<user>}
 */
const deleteById = async (id) => {
    // Check at least one super admin remains
    const userToDelete = await strapi.query('admin::user').findOne({
        where: { id },
        populate: ['roles'],
    });
    if (!userToDelete) {
        return null;
    }
    if (userToDelete) {
        if (userToDelete.roles.some((r) => r.code === constants_1.SUPER_ADMIN_CODE)) {
            const superAdminRole = await (0, utils_2.getService)('role').getSuperAdminWithUsersCount();
            if (superAdminRole.usersCount === 1) {
                throw new ValidationError('You must have at least one user with super admin role.');
            }
        }
    }
    const deletedUser = await strapi
        .query('admin::user')
        .delete({ where: { id }, populate: ['roles'] });
    strapi.eventHub.emit('user.delete', { user: sanitizeUser(deletedUser) });
    return deletedUser;
};
exports.deleteById = deleteById;
/** Delete a user
 * @param ids ids of the users to delete
 * @returns {Promise<user>}
 */
const deleteByIds = async (ids) => {
    // Check at least one super admin remains
    const superAdminRole = await (0, utils_2.getService)('role').getSuperAdminWithUsersCount();
    const nbOfSuperAdminToDelete = await strapi.query('admin::user').count({
        where: {
            id: ids,
            roles: { id: superAdminRole.id },
        },
    });
    if (superAdminRole.usersCount === nbOfSuperAdminToDelete) {
        throw new ValidationError('You must have at least one user with super admin role.');
    }
    const deletedUsers = [];
    for (const id of ids) {
        const deletedUser = await strapi.query('admin::user').delete({
            where: { id },
            populate: ['roles'],
        });
        deletedUsers.push(deletedUser);
    }
    strapi.eventHub.emit('user.delete', {
        users: deletedUsers.map((deletedUser) => sanitizeUser(deletedUser)),
    });
    return deletedUsers;
};
exports.deleteByIds = deleteByIds;
/** Count the users that don't have any associated roles
 * @returns {Promise<number>}
 */
const countUsersWithoutRole = async () => {
    return strapi.query('admin::user').count({
        where: {
            roles: {
                id: { $null: true },
            },
        },
    });
};
exports.countUsersWithoutRole = countUsersWithoutRole;
/**
 * Count the number of users based on search params
 * @param params params used for the query
 * @returns {Promise<number>}
 */
const count = async (where = {}) => {
    return strapi.query('admin::user').count({ where });
};
exports.count = count;
/** Assign some roles to several users
 * @returns {undefined}
 */
const assignARoleToAll = async (roleId) => {
    const users = await strapi.query('admin::user').findMany({
        select: ['id'],
        where: {
            roles: { id: { $null: true } },
        },
    });
    await Promise.all(users.map((user) => {
        return strapi.query('admin::user').update({
            where: { id: user.id },
            data: { roles: [roleId] },
        });
    }));
};
exports.assignARoleToAll = assignARoleToAll;
/** Display a warning if some users don't have at least one role
 * @returns {Promise<>}
 */
const displayWarningIfUsersDontHaveRole = async () => {
    const count = await countUsersWithoutRole();
    if (count > 0) {
        strapi.log.warn(`Some users (${count}) don't have any role.`);
    }
};
exports.displayWarningIfUsersDontHaveRole = displayWarningIfUsersDontHaveRole;
/** Returns an array of interface languages currently used by users
 * @returns {Promise<Array<string>>}
 */
const getLanguagesInUse = async () => {
    const users = await strapi.query('admin::user').findMany({ select: ['preferedLanguage'] });
    return users.map((user) => user.preferedLanguage || 'en');
};
exports.getLanguagesInUse = getLanguagesInUse;
//# sourceMappingURL=user.js.map