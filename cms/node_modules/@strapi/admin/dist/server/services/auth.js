"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetPassword = exports.forgotPassword = exports.hashPassword = exports.validatePassword = exports.checkCredentials = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@strapi/utils");
const utils_2 = require("../utils");
const { ApplicationError } = utils_1.errors;
/**
 * hashes a password
 * @param {string} password - password to hash
 * @returns {string} hashed password
 */
const hashPassword = (password) => bcryptjs_1.default.hash(password, 10);
exports.hashPassword = hashPassword;
/**
 * Validate a password
 * @param {string} password
 * @param {string} hash
 * @returns {Promise<boolean>} is the password valid
 */
const validatePassword = (password, hash) => bcryptjs_1.default.compare(password, hash);
exports.validatePassword = validatePassword;
/**
 * Check login credentials
 * @param {Object} options
 * @param {string} options.email
 * @param {string} options.password
 */
const checkCredentials = async ({ email, password }) => {
    const user = await strapi.query('admin::user').findOne({ where: { email } });
    if (!user || !user.password) {
        return [null, false, { message: 'Invalid credentials' }];
    }
    const isValid = await validatePassword(password, user.password);
    if (!isValid) {
        return [null, false, { message: 'Invalid credentials' }];
    }
    if (!(user.isActive === true)) {
        return [null, false, { message: 'User not active' }];
    }
    return [null, user];
};
exports.checkCredentials = checkCredentials;
/**
 * Send an email to the user if it exists or do nothing
 * @param {Object} param params
 * @param {string} param.email user email for which to reset the password
 */
const forgotPassword = async ({ email } = {}) => {
    const user = await strapi.query('admin::user').findOne({ where: { email, isActive: true } });
    if (!user) {
        return;
    }
    const resetPasswordToken = (0, utils_2.getService)('token').createToken();
    await (0, utils_2.getService)('user').updateById(user.id, { resetPasswordToken });
    // Send an email to the admin.
    const url = `${(0, utils_1.getAbsoluteAdminUrl)(strapi.config)}/auth/reset-password?code=${resetPasswordToken}`;
    return strapi
        .plugin('email')
        .service('email')
        .sendTemplatedEmail({
        to: user.email,
        from: strapi.config.get('admin.forgotPassword.from'),
        replyTo: strapi.config.get('admin.forgotPassword.replyTo'),
    }, strapi.config.get('admin.forgotPassword.emailTemplate'), {
        url,
        user: lodash_1.default.pick(user, ['email', 'firstname', 'lastname', 'username']),
    })
        .catch((err) => {
        // log error server side but do not disclose it to the user to avoid leaking informations
        strapi.log.error(err);
    });
};
exports.forgotPassword = forgotPassword;
/**
 * Reset a user password
 * @param {Object} param params
 * @param {string} param.resetPasswordToken token generated to request a password reset
 * @param {string} param.password new user password
 */
const resetPassword = async ({ resetPasswordToken, password } = {}) => {
    const matchingUser = await strapi
        .query('admin::user')
        .findOne({ where: { resetPasswordToken, isActive: true } });
    if (!matchingUser) {
        throw new ApplicationError();
    }
    return (0, utils_2.getService)('user').updateById(matchingUser.id, {
        password,
        resetPasswordToken: null,
    });
};
exports.resetPassword = resetPassword;
//# sourceMappingURL=auth.js.map