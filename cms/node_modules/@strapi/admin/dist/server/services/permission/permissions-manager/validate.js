"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ability_1 = require("@casl/ability");
const extra_1 = require("@casl/ability/extra");
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const user_1 = require("../../../domain/user");
const { ValidationError } = utils_1.errors;
const { throwPassword, throwDisallowedFields } = utils_1.validate.visitors;
const { constants, isScalarAttribute, getNonVisibleAttributes, getWritableAttributes } = utils_1.contentTypes;
const { ID_ATTRIBUTE, CREATED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE, } = constants;
const COMPONENT_FIELDS = ['__component'];
const STATIC_FIELDS = [ID_ATTRIBUTE];
const throwInvalidParam = ({ key }) => {
    throw new ValidationError(`Invalid parameter ${key}`);
};
exports.default = ({ action, ability, model }) => {
    const schema = strapi.getModel(model);
    const createValidateQuery = (options = {}) => {
        const { fields } = options;
        // TODO: validate relations to admin users in all validators
        const permittedFields = fields.shouldIncludeAll ? null : getQueryFields(fields.permitted);
        const validateFilters = (0, utils_1.pipeAsync)(utils_1.traverse.traverseQueryFilters(throwDisallowedFields(permittedFields), { schema }), utils_1.traverse.traverseQueryFilters(throwDisallowedAdminUserFields, { schema }), utils_1.traverse.traverseQueryFilters(throwPassword, { schema }), utils_1.traverse.traverseQueryFilters(({ key, value }) => {
            if ((0, fp_1.isObject)(value) && (0, fp_1.isEmpty)(value)) {
                throwInvalidParam({ key });
            }
        }, { schema }));
        const validateSort = (0, utils_1.pipeAsync)(utils_1.traverse.traverseQuerySort(throwDisallowedFields(permittedFields), { schema }), utils_1.traverse.traverseQuerySort(throwDisallowedAdminUserFields, { schema }), utils_1.traverse.traverseQuerySort(throwPassword, { schema }), utils_1.traverse.traverseQuerySort(({ key, attribute, value }) => {
            if (!isScalarAttribute(attribute) && (0, fp_1.isEmpty)(value)) {
                throwInvalidParam({ key });
            }
        }, { schema }));
        const validateFields = (0, utils_1.pipeAsync)(utils_1.traverse.traverseQueryFields(throwDisallowedFields(permittedFields), { schema }), utils_1.traverse.traverseQueryFields(throwPassword, { schema }));
        return async (query) => {
            if (query.filters) {
                await validateFilters(query.filters);
            }
            if (query.sort) {
                await validateSort(query.sort);
            }
            if (query.fields) {
                await validateFields(query.fields);
            }
            return true;
        };
    };
    const createValidateInput = (options = {}) => {
        const { fields } = options;
        const permittedFields = fields.shouldIncludeAll ? null : getInputFields(fields.permitted);
        return (0, utils_1.pipeAsync)(
        // Remove fields hidden from the admin
        (0, utils_1.traverseEntity)(throwHiddenFields, { schema }), 
        // Remove not allowed fields (RBAC)
        // @ts-expect-error
        (0, utils_1.traverseEntity)(throwDisallowedFields(permittedFields), { schema }), 
        // Remove roles from createdBy & updatedBy fields
        omitCreatorRoles);
    };
    const wrapValidate = (createValidateFunction) => {
        // @ts-expect-error
        const wrappedValidate = async (data, options = {}) => {
            if ((0, fp_1.isArray)(data)) {
                return Promise.all(data.map((entity) => wrappedValidate(entity, options)));
            }
            const { subject, action: actionOverride } = getDefaultOptions(data, options);
            const permittedFields = (0, extra_1.permittedFieldsOf)(ability, actionOverride, subject, {
                fieldsFrom: (rule) => rule.fields || [],
            });
            const hasAtLeastOneRegistered = (0, fp_1.some)((fields) => !(0, fp_1.isNil)(fields), (0, fp_1.flatMap)((0, fp_1.prop)('fields'), ability.rulesFor(actionOverride, (0, ability_1.detectSubjectType)(subject))));
            const shouldIncludeAllFields = (0, fp_1.isEmpty)(permittedFields) && !hasAtLeastOneRegistered;
            const validateOptions = {
                ...options,
                fields: {
                    shouldIncludeAll: shouldIncludeAllFields,
                    permitted: permittedFields,
                    hasAtLeastOneRegistered,
                },
            };
            const validateFunction = createValidateFunction(validateOptions);
            return validateFunction(data);
        };
        return wrappedValidate;
    };
    const getDefaultOptions = (data, options) => {
        return (0, fp_1.defaults)({ subject: (0, ability_1.subject)(model, data), action }, options);
    };
    /**
     * Omit creator fields' (createdBy & updatedBy) roles from the admin API responses
     */
    const omitCreatorRoles = (0, fp_1.omit)([`${CREATED_BY_ATTRIBUTE}.roles`, `${UPDATED_BY_ATTRIBUTE}.roles`]);
    /**
     * Visitor used to remove hidden fields from the admin API responses
     */
    const throwHiddenFields = ({ key, schema }) => {
        const isHidden = (0, fp_1.getOr)(false, ['config', 'attributes', key, 'hidden'], schema);
        if (isHidden) {
            throwInvalidParam({ key });
        }
    };
    /**
     * Visitor used to omit disallowed fields from the admin users entities & avoid leaking sensitive information
     */
    const throwDisallowedAdminUserFields = ({ key, attribute, schema }) => {
        if (schema.uid === 'admin::user' && attribute && !user_1.ADMIN_USER_ALLOWED_FIELDS.includes(key)) {
            throwInvalidParam({ key });
        }
    };
    const getInputFields = (fields = []) => {
        const nonVisibleAttributes = getNonVisibleAttributes(schema);
        const writableAttributes = getWritableAttributes(schema);
        const nonVisibleWritableAttributes = (0, fp_1.intersection)(nonVisibleAttributes, writableAttributes);
        return (0, fp_1.uniq)([
            ...fields,
            ...STATIC_FIELDS,
            ...COMPONENT_FIELDS,
            ...nonVisibleWritableAttributes,
        ]);
    };
    const getQueryFields = (fields = []) => {
        return (0, fp_1.uniq)([
            ...fields,
            ...STATIC_FIELDS,
            ...COMPONENT_FIELDS,
            CREATED_AT_ATTRIBUTE,
            UPDATED_AT_ATTRIBUTE,
            PUBLISHED_AT_ATTRIBUTE,
        ]);
    };
    return {
        validateQuery: wrapValidate(createValidateQuery),
        validateInput: wrapValidate(createValidateInput),
    };
};
//# sourceMappingURL=validate.js.map