"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanPermissionsInDatabase = exports.findUserPermissions = exports.findMany = exports.createMany = exports.deleteByIds = exports.deleteByRolesIds = void 0;
const fp_1 = require("lodash/fp");
const p_map_1 = __importDefault(require("p-map"));
const utils_1 = require("../../utils");
const index_1 = __importDefault(require("../../domain/permission/index"));
/**
 * Delete permissions of roles in database
 * @param rolesIds ids of roles
 * @returns {Promise<array>}
 */
const deleteByRolesIds = async (rolesIds) => {
    const permissionsToDelete = await strapi.query('admin::permission').findMany({
        select: ['id'],
        where: {
            role: { id: rolesIds },
        },
    });
    if (permissionsToDelete.length > 0) {
        await (0, exports.deleteByIds)(permissionsToDelete.map((0, fp_1.prop)('id')));
    }
};
exports.deleteByRolesIds = deleteByRolesIds;
/**
 * Delete permissions
 * @param ids ids of permissions
 * @returns {Promise<array>}
 */
const deleteByIds = async (ids) => {
    const result = [];
    for (const id of ids) {
        const queryResult = await strapi.query('admin::permission').delete({ where: { id } });
        result.push(queryResult);
    }
    strapi.eventHub.emit('permission.delete', { permissions: result });
};
exports.deleteByIds = deleteByIds;
/**
 * Create many permissions
 * @param permissions
 * @returns {Promise<*[]|*>}
 */
const createMany = async (permissions) => {
    const createdPermissions = [];
    for (const permission of permissions) {
        const newPerm = await strapi.query('admin::permission').create({ data: permission });
        createdPermissions.push(newPerm);
    }
    const permissionsToReturn = index_1.default.toPermission(createdPermissions);
    strapi.eventHub.emit('permission.create', { permissions: permissionsToReturn });
    return permissionsToReturn;
};
exports.createMany = createMany;
/**
 * Update a permission
 * @returns {Promise<*[]|*>}
 * @param params
 * @param attributes
 */
const update = async (params, attributes) => {
    const updatedPermission = await strapi
        .query('admin::permission')
        .update({ where: params, data: attributes });
    const permissionToReturn = index_1.default.toPermission(updatedPermission);
    strapi.eventHub.emit('permission.update', { permissions: permissionToReturn });
    return permissionToReturn;
};
/**
 * Find assigned permissions in the database
 * @param params query params to find the permissions
 * @returns {Promise<Permission[]>}
 */
const findMany = async (params = {}) => {
    const rawPermissions = await strapi.query('admin::permission').findMany(params);
    return index_1.default.toPermission(rawPermissions);
};
exports.findMany = findMany;
/**
 * Find all permissions for a user
 * @param user - user
 * @returns {Promise<Permission[]>}
 */
const findUserPermissions = async (user) => {
    return (0, exports.findMany)({ where: { role: { users: { id: user.id } } } });
};
exports.findUserPermissions = findUserPermissions;
const filterPermissionsToRemove = async (permissions) => {
    const { actionProvider } = (0, utils_1.getService)('permission');
    const permissionsToRemove = [];
    for (const permission of permissions) {
        const { subjects, options = {} } = actionProvider.get(permission.action) || {};
        const { applyToProperties } = options;
        const invalidProperties = await Promise.all((applyToProperties || []).map(async (property) => {
            const applies = await actionProvider.appliesToProperty(property, permission.action, permission.subject);
            return applies && (0, fp_1.isNil)(index_1.default.getProperty(property, permission));
        }));
        const isRegisteredAction = actionProvider.has(permission.action);
        const hasInvalidProperties = (0, fp_1.isArray)(applyToProperties) && invalidProperties.every((0, fp_1.eq)(true));
        const isInvalidSubject = (0, fp_1.isArray)(subjects) && !subjects.includes(permission.subject);
        // If the permission has an invalid action, an invalid subject or invalid properties, then add it to the toBeRemoved collection
        if (!isRegisteredAction || isInvalidSubject || hasInvalidProperties) {
            permissionsToRemove.push(permission);
        }
    }
    return permissionsToRemove;
};
/**
 * Removes permissions in database that don't exist anymore
 * @returns {Promise<>}
 */
const cleanPermissionsInDatabase = async () => {
    const pageSize = 200;
    const contentTypeService = (0, utils_1.getService)('content-type');
    const total = await strapi.query('admin::permission').count();
    const pageCount = Math.ceil(total / pageSize);
    for (let page = 0; page < pageCount; page += 1) {
        // 1. Find invalid permissions and collect their ID to delete them later
        const results = await strapi
            .query('admin::permission')
            .findMany({ limit: pageSize, offset: page * pageSize });
        const permissions = index_1.default.toPermission(results);
        const permissionsToRemove = await filterPermissionsToRemove(permissions);
        const permissionsIdToRemove = (0, fp_1.map)((0, fp_1.prop)('id'), permissionsToRemove);
        // 2. Clean permissions' fields (add required ones, remove the non-existing ones)
        // @ts-expect-error - Make toPermission return an array if the input was an array
        const remainingPermissions = permissions.filter((permission) => !permissionsIdToRemove.includes(permission.id));
        const permissionsWithCleanFields = contentTypeService.cleanPermissionFields(remainingPermissions);
        // Update only the ones that need to be updated
        const permissionsNeedingToBeUpdated = (0, fp_1.differenceWith)((a, b) => {
            return a.id === b.id && (0, fp_1.xor)(a.properties.fields, b.properties.fields).length === 0;
        }, permissionsWithCleanFields, remainingPermissions);
        const updatePromiseProvider = (permission) => {
            return update({ id: permission.id }, permission);
        };
        // Execute all the queries, update the database
        await Promise.all([
            (0, exports.deleteByIds)(permissionsIdToRemove),
            // @ts-ignore
            (0, p_map_1.default)(permissionsNeedingToBeUpdated, updatePromiseProvider, {
                concurrency: 100,
                stopOnError: true,
            }),
        ]);
    }
};
exports.cleanPermissionsInDatabase = cleanPermissionsInDatabase;
exports.default = {
    createMany: exports.createMany,
    findMany: exports.findMany,
    deleteByRolesIds: exports.deleteByRolesIds,
    deleteByIds: exports.deleteByIds,
    findUserPermissions: exports.findUserPermissions,
    cleanPermissionsInDatabase: exports.cleanPermissionsInDatabase,
};
//# sourceMappingURL=queries.js.map