"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ability_1 = require("@casl/ability");
const extra_1 = require("@casl/ability/extra");
const fp_1 = require("lodash/fp");
const utils_1 = require("@strapi/utils");
const user_1 = require("../../../domain/user");
const { visitors: { removePassword }, } = utils_1.sanitize;
const { constants, isScalarAttribute, getNonVisibleAttributes, getNonWritableAttributes, getWritableAttributes, } = utils_1.contentTypes;
const { ID_ATTRIBUTE, CREATED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE, } = constants;
const COMPONENT_FIELDS = ['__component'];
const STATIC_FIELDS = [ID_ATTRIBUTE];
exports.default = ({ action, ability, model }) => {
    const schema = strapi.getModel(model);
    const { removeDisallowedFields } = utils_1.sanitize.visitors;
    const createSanitizeQuery = (options = {}) => {
        const { fields } = options;
        // TODO: sanitize relations to admin users in all sanitizers
        const permittedFields = fields.shouldIncludeAll ? null : getQueryFields(fields.permitted);
        const sanitizeFilters = (0, utils_1.pipeAsync)(utils_1.traverse.traverseQueryFilters(removeDisallowedFields(permittedFields), { schema }), utils_1.traverse.traverseQueryFilters(omitDisallowedAdminUserFields, { schema }), utils_1.traverse.traverseQueryFilters(omitHiddenFields, { schema }), utils_1.traverse.traverseQueryFilters(removePassword, { schema }), utils_1.traverse.traverseQueryFilters(({ key, value }, { remove }) => {
            if ((0, fp_1.isObject)(value) && (0, fp_1.isEmpty)(value)) {
                remove(key);
            }
        }, { schema }));
        const sanitizeSort = (0, utils_1.pipeAsync)(utils_1.traverse.traverseQuerySort(removeDisallowedFields(permittedFields), { schema }), utils_1.traverse.traverseQuerySort(omitDisallowedAdminUserFields, { schema }), utils_1.traverse.traverseQuerySort(omitHiddenFields, { schema }), utils_1.traverse.traverseQuerySort(removePassword, { schema }), utils_1.traverse.traverseQuerySort(({ key, attribute, value }, { remove }) => {
            if (!isScalarAttribute(attribute) && (0, fp_1.isEmpty)(value)) {
                remove(key);
            }
        }, { schema }));
        const sanitizePopulate = (0, utils_1.pipeAsync)(utils_1.traverse.traverseQueryPopulate(removeDisallowedFields(permittedFields), { schema }), utils_1.traverse.traverseQueryPopulate(omitDisallowedAdminUserFields, { schema }), utils_1.traverse.traverseQueryPopulate(omitHiddenFields, { schema }), utils_1.traverse.traverseQueryPopulate(removePassword, { schema }));
        const sanitizeFields = (0, utils_1.pipeAsync)(utils_1.traverse.traverseQueryFields(removeDisallowedFields(permittedFields), { schema }), utils_1.traverse.traverseQueryFields(omitHiddenFields, { schema }), utils_1.traverse.traverseQueryFields(removePassword, { schema }));
        return async (query) => {
            const sanitizedQuery = (0, fp_1.cloneDeep)(query);
            if (query.filters) {
                Object.assign(sanitizedQuery, { filters: await sanitizeFilters(query.filters) });
            }
            if (query.sort) {
                Object.assign(sanitizedQuery, { sort: await sanitizeSort(query.sort) });
            }
            if (query.populate) {
                Object.assign(sanitizedQuery, { populate: await sanitizePopulate(query.populate) });
            }
            if (query.fields) {
                Object.assign(sanitizedQuery, { fields: await sanitizeFields(query.fields) });
            }
            return sanitizedQuery;
        };
    };
    const createSanitizeOutput = (options = {}) => {
        const { fields } = options;
        const permittedFields = fields.shouldIncludeAll ? null : getOutputFields(fields.permitted);
        return (0, utils_1.pipeAsync)(
        // Remove fields hidden from the admin
        (0, utils_1.traverseEntity)(omitHiddenFields, { schema }), 
        // Remove unallowed fields from admin::user relations
        // @ts-expect-error
        (0, utils_1.traverseEntity)(pickAllowedAdminUserFields, { schema }), 
        // Remove not allowed fields (RBAC)
        (0, utils_1.traverseEntity)(removeDisallowedFields(permittedFields), { schema }), 
        // Remove all fields of type 'password'
        utils_1.sanitize.sanitizers.sanitizePasswords(schema));
    };
    const createSanitizeInput = (options = {}) => {
        const { fields } = options;
        const permittedFields = fields.shouldIncludeAll ? null : getInputFields(fields.permitted);
        return (0, utils_1.pipeAsync)(
        // Remove fields hidden from the admin
        (0, utils_1.traverseEntity)(omitHiddenFields, { schema }), 
        // Remove not allowed fields (RBAC)
        // @ts-expect-error
        (0, utils_1.traverseEntity)(removeDisallowedFields(permittedFields), { schema }), 
        // Remove roles from createdBy & updateBy fields
        omitCreatorRoles);
    };
    const wrapSanitize = (createSanitizeFunction) => {
        // @ts-expect-error
        const wrappedSanitize = async (data, options = {}) => {
            if ((0, fp_1.isArray)(data)) {
                return Promise.all(data.map((entity) => wrappedSanitize(entity, options)));
            }
            const { subject, action: actionOverride } = getDefaultOptions(data, options);
            const permittedFields = (0, extra_1.permittedFieldsOf)(ability, actionOverride, subject, {
                fieldsFrom: (rule) => rule.fields || [],
            });
            const hasAtLeastOneRegistered = (0, fp_1.some)((fields) => !(0, fp_1.isNil)(fields), (0, fp_1.flatMap)((0, fp_1.prop)('fields'), ability.rulesFor(actionOverride, (0, ability_1.detectSubjectType)(subject))));
            const shouldIncludeAllFields = (0, fp_1.isEmpty)(permittedFields) && !hasAtLeastOneRegistered;
            const sanitizeOptions = {
                ...options,
                fields: {
                    shouldIncludeAll: shouldIncludeAllFields,
                    permitted: permittedFields,
                    hasAtLeastOneRegistered,
                },
            };
            const sanitizeFunction = createSanitizeFunction(sanitizeOptions);
            return sanitizeFunction(data);
        };
        return wrappedSanitize;
    };
    const getDefaultOptions = (data, options) => {
        return (0, fp_1.defaults)({ subject: (0, ability_1.subject)(model, data), action }, options);
    };
    /**
     * Omit creator fields' (createdBy & updatedBy) roles from the admin API responses
     */
    const omitCreatorRoles = (0, fp_1.omit)([`${CREATED_BY_ATTRIBUTE}.roles`, `${UPDATED_BY_ATTRIBUTE}.roles`]);
    /**
     * Visitor used to remove hidden fields from the admin API responses
     */
    const omitHiddenFields = ({ key, schema }, { remove }) => {
        const isHidden = (0, fp_1.getOr)(false, ['config', 'attributes', key, 'hidden'], schema);
        if (isHidden) {
            remove(key);
        }
    };
    /**
     * Visitor used to only select needed fields from the admin users entities & avoid leaking sensitive information
     */
    const pickAllowedAdminUserFields = ({ attribute, key, value }, { set }) => {
        const pickAllowedFields = (0, fp_1.pick)(user_1.ADMIN_USER_ALLOWED_FIELDS);
        if (attribute.type === 'relation' && attribute.target === 'admin::user' && value) {
            if (Array.isArray(value)) {
                set(key, value.map(pickAllowedFields));
            }
            else {
                set(key, pickAllowedFields(value));
            }
        }
    };
    /**
     * Visitor used to omit disallowed fields from the admin users entities & avoid leaking sensitive information
     */
    const omitDisallowedAdminUserFields = ({ key, attribute, schema }, { remove }) => {
        if (schema.uid === 'admin::user' && attribute && !user_1.ADMIN_USER_ALLOWED_FIELDS.includes(key)) {
            remove(key);
        }
    };
    const getInputFields = (fields = []) => {
        const nonVisibleAttributes = getNonVisibleAttributes(schema);
        const writableAttributes = getWritableAttributes(schema);
        const nonVisibleWritableAttributes = (0, fp_1.intersection)(nonVisibleAttributes, writableAttributes);
        return (0, fp_1.uniq)([
            ...fields,
            ...STATIC_FIELDS,
            ...COMPONENT_FIELDS,
            ...nonVisibleWritableAttributes,
        ]);
    };
    const getOutputFields = (fields = []) => {
        const nonWritableAttributes = getNonWritableAttributes(schema);
        const nonVisibleAttributes = getNonVisibleAttributes(schema);
        return (0, fp_1.uniq)([
            ...fields,
            ...STATIC_FIELDS,
            ...COMPONENT_FIELDS,
            ...nonWritableAttributes,
            ...nonVisibleAttributes,
            CREATED_AT_ATTRIBUTE,
            UPDATED_AT_ATTRIBUTE,
        ]);
    };
    const getQueryFields = (fields = []) => {
        const nonVisibleAttributes = getNonVisibleAttributes(schema);
        const writableAttributes = getWritableAttributes(schema);
        const nonVisibleWritableAttributes = (0, fp_1.intersection)(nonVisibleAttributes, writableAttributes);
        return (0, fp_1.uniq)([
            ...fields,
            ...STATIC_FIELDS,
            ...COMPONENT_FIELDS,
            ...nonVisibleWritableAttributes,
            CREATED_AT_ATTRIBUTE,
            UPDATED_AT_ATTRIBUTE,
            PUBLISHED_AT_ATTRIBUTE,
            CREATED_BY_ATTRIBUTE,
            UPDATED_BY_ATTRIBUTE,
        ]);
    };
    return {
        sanitizeOutput: wrapSanitize(createSanitizeOutput),
        sanitizeInput: wrapSanitize(createSanitizeInput),
        sanitizeQuery: wrapSanitize(createSanitizeQuery),
    };
};
//# sourceMappingURL=sanitize.js.map